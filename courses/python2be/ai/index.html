<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>PI2C - IA</title>
	<script src="https://quentin.lurkin.xyz/deck.js"></script>
	<style>
		.mode-deck section.code::before {
			position: fixed;
			background-color: #f0f0f0;
			top: 0;
			bottom: 0;
			left: 0;
			right: 0;
			content: '';
			z-index: 10;
			display: block;
		}
		.mode-deck section.code>* {
			z-index: 100;
		}

		.mode-deck section.code h2 {
			z-index: 1000;
			background-color: #555;
			
		}

		.mode-deck section.code {
			width: 95%;
		}

		.mode-deck section.code::after {
			content: '';
			position: fixed;
			top: 0;
			left: 0;
			bottom: 0;
			width: 3%;
			background-color: #bbb;
			z-index: 20;
		}
	</style>
</head>
<body>
	<section>
		<h1>PI2C - Types abstraits de données, Backtracking, Recherche, Théorie des jeux</h1>
	</section>

	<section>
		<h2>Types abstraits de données</h2>
		<ul>
			<li><strong>Type abstrait de données</strong> (TAD) spécifie mathématiquement
				<ul>
					<li>Un ensemble de données</li>
					<li>Les opérations qu’on peut effectuer</li>
				</ul>
			</li>
			<li>Correspond à un <strong>cahier des charges</strong> <small>Implémentation du CDC par une structure de données</small></li>
			<li><strong>Plusieurs implémentations possibles</strong> pour un même TAD <small>Se différencient par la complexité calculatoire et spatiale</small></li>
		</ul>
	</section>
	<section>
		<h2>File</h2>
		<ul>
			<li>Séquence de type <strong>First-in First-out</strong> (FIFO)
				<small>Le premier élément qui a été ajouté sera le premier à sortir</small>
			</li>
			<li>Opérations possibles:
				<ul>
					<li><code>size</code>: donne la taille de la file</li>
					<li><code>isEmpty</code>: teste si la file est vide</li>
					<li><code>front</code>: récupère l’élément en début de file</li>
					<li><code>enqueue</code>: ajoute un élément en fin de file</li>
					<li><code>dequeue</code>: retire l’élément en début de file</li>
				</ul>
			</li>
		</ul>
		<figure>
			<img src="./queue.png" class="third2">
		</figure>
	</section>
	<section>
		<h2>Pile</h2>
		<ul>
			<li>Séquence de type <strong>Last-in First-out</strong> (LIFO)
				<small>Le dernier élément qui a été ajouté sera le premier à sortir</small>
			</li>
			<li>Opérations possibles:
				<ul>
					<li><code>size</code>: donne la taille de la pile</li>
					<li><code>isEmpty</code>: teste si la pile est vide</li>
					<li><code>top</code>: récupère l’élément en haut de la pile</li>
					<li><code>push</code>: ajoute un élément en haut de la pile</li>
					<li><code>pop</code>: retire l’élément en haut de la pile</li>
				</ul>
			</li>
		</ul>
		<figure>
			<img src="./stack.png" class="half">
		</figure>
	</section>
	<section>
		<h2>Arbre</h2>
		<ul>
			<li>Éléments d’un <strong>arbre</strong> organisés de manière hiérarchique
				<small>Un arbre est un ensemble de nœuds (qui contiennent les valeurs)</small>
			</li>
			<li>Chaque nœud possède un <strong>parent</strong> et zéro ou plusieurs <strong>enfants</strong>
				<small>Sauf la racine de l’arbre qui n’a pas de parent</small>
			</li>
		</ul>
		<figure>
			<img src="./tree.png">
		</figure>
	</section>
	<section>
		<h2>Définition récursive</h2>
		<ul>
			<li><strong>Deux cas</strong> possibles pour définir un arbre
				<ul>
					<li>Un arbre vide (sans enfants)</li>
					<li>Un nœud avec un élément et une liste de sous-arbres</li>
				</ul>
			</li>
			<li><strong>Opérations</strong> possibles
				<ul>
					<li><code>size</code>: donne la taille de l’arbre</li>
					<li><code>value</code>: récupère la valeur stockée à la racine de l’arbre</li>
					<li><code>children</code>: récupère la liste des sous-arbres enfants de la racine</li>
					<li><code>addChild</code>: ajoute un sous-arbre comme enfant à la racine</li>
				</ul>
			</li>
		</ul>
		<pre><code>
			import copy

			class Tree :
				def __init__ (self, value, children=[]):
					self.__value = value
					self.__children = copy.deepcopy(children)

				@property
				def value(self):
					return self.__value

				@property
				def children(self):
					return copy.deepcopy(self.__children)

				def addChild (self, tree):
					self.__children.append(tree)

				@property
				def size(self):
					result = 1
					for child in self.__children:
						result += child.size
					return result

				def __getitem__(self, index):
					return self.__children[index]

				def __str__(self):
					def _str (tree, level):
						result = '[{}]\n'.format(tree.__value)
						for child in tree.children:
							result += '{}|--{}'.format(' ' * level, _str(
							child, level + 1))
						return result
					return _str(self, 0)
					

			t1 = Tree(-9)
			t2 = Tree(25, [t1])
			t3 = Tree(12)
			t4 = Tree(14)
			
			t = Tree(11, [t2, t3, t4])
		</code></pre>
		<figure>
			<img src="./tree-example.png" class="third2">
		</figure>
	</section>
	<section>
		<h2>Backtracking</h2>
		<ul>
			<li>Récursion beaucoup utilisée en <strong>intelligence artificielle</strong>
				<small>Recherche choix optimal dans un ensemble de possibilités</small>
			</li>
			<li>Faire une <strong>tentative</strong> de séquences de choix
				<ul>
					<li>Possibilité de faire marche arrière par rapport à un choix</li>
					<li>Exploration de nouvelles décisions</li>
				</ul>
			</li>
			<li>La <strong>récursion</strong> permet de faire facilement du <strong>backtracking</strong></li>
		</ul>
	</section>
	<section class='code'>
		<h2>Labyrinthe</h2>
		<pre><code>
			laby = [
				"##########",
				"#        E",
				"# # ######",
				"# #      #",
				"# # # ####",
				"#####    #",
				"#   # ####",
				"# # # #  #",
				"# #      #",
				"##########",
			]

			def set(laby, l, c, char):
				laby[l] = laby[l][:c] + char + laby[l][c+1:]

			def printLaby(laby):
				for line in laby:
					print(line)

			directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

			# (l, c) is the starting point
			# return True if an exit is found
			def find(laby, l, c):
				# Did we find the exit?
				if laby[l][c] == 'E':
					return True

				# Are we in a wall or in our way?
				if laby[l][c] in '#*':
					return False

				# Trace our way
				set(laby, l, c, '*')

				# Search all directions
				for direction in directions:
					if find(laby, l+direction[0], c+direction[1]):
						return True

				# No exit found, backtrack
				set(laby, l, c, ' ')
				return False
			
			find(laby, 8, 1)
			printLaby(laby)
		</code></pre>
	</section>
	<section>
		<h2>Recherche</h2>
	</section>
	<section>
		<h2>Théorie des jeux</h2>
	</section>
</body>
</html>