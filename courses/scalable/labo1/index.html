<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>AD5L - Labo1</title>
	<script src="https://quentin.lurkin.xyz/document.js"></script>
</head>
<body>
	<h1>AD5L - Labo 1 <small>Tri distribué</small></h1>

	<h2>Introduction</h2>
	<p>De nos jours, il est de plus en plus courant qu'une application doive gérer un charge de travail (workload \(W_l\)) qui varie au cours du temps. Pour gérer plus de charge de travail, il faut plus de capacité hardware (hardware capacity \(H_c\)). Il est cependant erroné de penser qu'il suffit de mettre deux fois plus de capacité hardware pour pouvoir gérer deux fois plus de charge. C'est ce qu'on appèle le facteur de scalabilité (Scalability factor \(S_f\)). \[ W_l = S_f \times H_c\]</p>
	<p>Si ce facteur est constant on parle de scalabilité linéaire, mais ce n'est généralement pas le cas.</p>
	<p>Il y a deux façons d'augmenter la capacité hardware:</p>
	<ul>
		<li>Scalabilité verticale,</li>
		<li>Scalabilité horizontale.</li>
	</ul>

	<p>La scalabilité verticale consiste à augmenter les capacités de la machine (CPU, RAM, Disques). cette forme de scalabilité a une limite puisqu'il y a un moment où il n'existe de plus de meilleur hardware que celui qu'on a. De plus les prix de ces hardwares performants sont en générale prohibitifs.</p>

	<p>La scalabilité horizontale consiste à diviser la charge de travail sur plusieurs machines.</p>

	<p>Dans les deux cas, le software doit être prévu pour tirer avantage du supplément de capacité qui est à sa disposition. Cela passe souvent par la parallélisation de tâches. En scalabilité verticale, on parallélisera pour exploiter tous les coeurs du CPU. En scalabilité horizontale, on parallélise pour exploiter toutes les machines en même temps.</p>

	<p>Les difficultés liées à la parallélisation sont:</p>
	<ul>
		<li>Les tâches doivent être indépendantes les unes des autres.</li>
		<li>Les tâches doivent avoir accès aux données.</li>
	</ul>

	<h2>Tri distribué</h2>
	<p>L'exercice de cette séance consiste à trier un très grand nombre d'entier en utilisant tous les coeurs de plusieurs machines (scalabilité verticale et horizontale).</p>

	<p>Chaque étudiant sera en charge d'implémenter un serveur de tri. L'enseignant sera responsable de l'application maitre qui reparti le travail entre les différents serveurs.</p>

	<p>Vous devez implémenter vous-même votre tri (interdit d'utiliser le tri inclus dans le langage). l'algorithme le plus utilisé est le quicksort dont vous pouvez trouver les détails sur internet.</p>

	<p>Chaque serveur de tri sera un serveur web. et la machine maitre fera des requêtes HTTP pour envoyer les données. La machine maitre sera elle aussi un serveur web de sorte que les données triées pourront être renvoyées par le même moyen.</p>

	<p>Toutes les requêtes seront des POST avec JSON en body.</p>

	<p>Votre serveur devra être capable de répondre au requêtes suivantes:</p>
	<ul>
		<li>Renvoyer un certain nombre de nombre aléatoire entre deux bornes:
			<pre><code class="lang-json">
				{
					"command": "sample",
					"size": 10,
					"begin": 0,
					"end": 10000000
				}
			</code></pre>
		</li>
		<li>Accepter les nombre à trier par partie:
			<pre><code class="lang-json">
				{
					"command": "sort",
					"id": 0,
					"order": 0,
					"last": false,
					"data": [3, 67, 87, 3, 1, 9867, 567]
				}
			</code></pre>
		</li>

	</ul>
	
</body>
</html>