<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed|Roboto+Mono|Roboto+Slab"><style>/* http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript+python */
	/**
	* prism.js default theme for JavaScript, CSS and HTML
	* Based on dabblet (http://dabblet.com)
	* @author Lea Verou
	*/
	
	code[class*="language-"],
	pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: 'Roboto Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;
	
	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;
	
	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	}
	
	pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
	code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
	}
	
	pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
	code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
	}
	
	@media print {
	code[class*="language-"],
	pre[class*="language-"] {
	  text-shadow: none;
	}
	}
	
	/* Code blocks */
	pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	}
	
	:not(pre) > code[class*="language-"],
	pre[class*="language-"] {
	background: #f5f2f0;
	}
	
	/* Inline code */
	:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
	}
	
	.token.comment,
	.token.prolog,
	.token.doctype,
	.token.cdata {
	color: slategray;
	}
	
	.token.punctuation {
	color: #999;
	}
	
	.namespace {
	opacity: .7;
	}
	
	.token.property,
	.token.tag,
	.token.boolean,
	.token.number,
	.token.constant,
	.token.symbol,
	.token.deleted {
	color: #905;
	}
	
	.token.selector,
	.token.attr-name,
	.token.string,
	.token.char,
	.token.builtin,
	.token.inserted {
	color: #690;
	}
	
	.token.operator,
	.token.entity,
	.token.url,
	.language-css .token.string,
	.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
	}
	
	.token.atrule,
	.token.attr-value,
	.token.keyword {
	color: #07a;
	}
	
	.token.function {
	color: #DD4A68;
	}
	
	.token.regex,
	.token.important,
	.token.variable {
	color: #e90;
	}
	
	.token.important,
	.token.bold {
	font-weight: bold;
	}
	.token.italic {
	font-style: italic;
	}
	
	.token.entity {
	cursor: help;
	}
	</style><style>/*************************** typography *********************************/
	body {
	  font-family: 'Roboto', Helvetica, sans-serif;
	  -webkit-font-smoothing: antialiased;
	  text-rendering: optimizeLegibility;
	  text-align: justify;
	  font-size: 16px;
	  line-height: 1.8;
	}
	
	section.question::before {
	  font-family: 'Roboto Condensed', sans-serif;
	  font-size: 1.2em;
	  font-weight: 900;
	  color: gray;
	  text-transform: uppercase;
	}
	
	section>h1 {
	  font-family: 'Roboto Condensed', sans-serif;
	  font-size: 1.6em;
	  font-weight: 900;
	  color: gray;
	  text-transform: uppercase;
	}
	
	section section>h1 {
	  font-family: 'Roboto Slab', serif;
	  font-size: 1.2em;
	  text-transform: none;
	}
	
	section section section>h1 {
	  font-size: 1em;
	  font-weight: 100;
	}
	
	header {
	  font-family: 'Roboto Slab', serif;
	  font-size: 2em;
	  line-height: 1;
	  border-bottom: 1px solid lightgray;
	}
	
	header small {
	  font-size: 65%;
	  color: gray;
	}
	
	pre, code {
	  font-family: 'Roboto Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	}
	
	pre.console {
	  color: rgb(248, 248, 242);
	}
	
	p code, h1 code, table code, header code, li code {
	  padding: 2px 4px;
	  font-size: 90%;
	  color: #c7254e;
	  background-color: #f9f2f4;
	  border-radius: 4px;
	}
	
	/*************************** spacing *********************************/
	body {
	  margin-top: 3cm;
	  max-width: 20cm;
	  margin-left: auto;
	  margin-right: auto;
	}
	
	section {
	  margin-bottom: 1cm;
	}
	
	p {
	  margin: 5mm 0;
	}
	
	section.question::before {
	  margin-bottom: 2mm;
	  display: block;
	}
	
	section>h1 {
	  margin-bottom: 2mm;
	  display: block;
	}
	
	header {
	  position: fixed;
	  top: 0;
	  left: 0;
	  right: 0;
	  padding: 5mm 0;
	  margin: 0 5mm;
	}
	
	header small {
	  margin-left: 5mm;
	}
	
	img {
	  display: block;
	  max-width: 100%;
	  margin: 5mm auto;
	}
	
	pre.console {
	  padding: 1em;
	}
	
	/*************************** numbering *********************************/
	body {
	  counter-reset: section question;
	}
	
	section.question::before {
	  counter-increment: question;
	  content: "Question " counter(question);
	}
	
	section {
	  counter-reset: subsection;
	}
	
	section>h1::before {
	  counter-increment: section;
	  content: counter(section) ". ";
	}
	
	section section {
	  counter-reset: subsubsection;
	}
	
	section section>h1::before {
	  counter-increment: subsection;
	  content: counter(section) "." counter(subsection) ". ";
	}
	
	section section section {
	  counter-reset: none;
	}
	
	section section section>h1::before {
	  counter-increment: subsubsection;
	  content: counter(section) "." counter(subsection) "." counter(subsubsection) ". ";
	}
	
	/*************************** boxes *********************************/
	header {
	  background-color: white;
	}
	
	pre, img {
	  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
				  0 1px 5px 0 rgba(0, 0, 0, 0.12),
				  0 3px 1px -2px rgba(0, 0, 0, 0.2);
	  border-radius: 4px;
	}
	
	pre.console {
	  background-color: #272822;
	}
	
	/*************************** print *********************************/
	section.question::before {
	  page-break-before: auto;
	}
	
	section>h1 {
	  page-break-before: auto;
	}
	
	section section>h1 {
	  page-break-before: auto;
	}
	
	section section section>h1 {
	  page-break-before: auto;
	}
	
	h1, header {
	  page-break-after: avoid;
	}
	
	@media print {
	  @page {
		size: A4;
		margin: 2cm 4cm;
	  }
	
	  pre, img {
		box-shadow: none;
		border: 1px solid lightgray;
	  }
	
	  header {
		position: static;
		margin-bottom: 1cm;
		margin-left: 0;
		margin-right: 0;
	  }
	
	  body {
		margin-top: 10px;
	  }
	}
	
	/*************************** table *********************************/
	
	table {
	  width: 100%;
	  max-width: 100%;
	  margin-bottom: 20px;
	  background-color: transparent;
	  border-spacing: 0;
	  border-collapse: collapse;
	  display: table;
	  border-color: grey;
	}
	
	tr {
	  display: table-row;
	  vertical-align: inherit;
	  border-color: inherit;
	}
	
	tr:nth-of-type(even) {
	  background-color: #f9f9f9;
	}
	
	tr:hover {
	  background-color: #f5f5f5;
	}
	
	th {
	  padding: 8px;
	  line-height: 1.42857143;
	  vertical-align: top;
	  border-top: 1px solid #ddd;
	  display: table-cell;
	  text-align: left;
	  font-weight: bold;
	}
	
	td {
	  padding: 8px;
	  line-height: 1.42857143;
	  vertical-align: top;
	  border-top: 1px solid #ddd;
	  display: table-cell;
	}
	
	</style></head><body><header>TW3C - Administration Linux - Séance 2</header><section><h1>Gestion des utilisateurs</h1><p>Le système, dès son installation, avant même la première connexion d'un utilisateur « physique » au système, a créé des utilisateurs système. Un utilisateur n'est donc pas uniquement une personne physique, le système a besoin d'utilisateurs pour sa gestion interne, notamment comme propriétaire des divers processus nécessaires au fonctionnement du système.</p><p>L'utilisateur qui a tous les droits sur la machine est l'utilisateur <code>root</code>. <code>root</code>, dans les systèmes Linux plus anciens, est un utilisateur comme les autres en dehors de ses droits. Sous Ubuntu, <code>root</code> n'a pas de mot de passe et on ne peux donc pas se connecter à son nom de manière classique. A la place, la commande <code>sudo</code> (Super User DO) permet d'effectuer une commande sous le nom du super utilisateur <code>root</code>.</p><p>Pour ajouter un utilisateur, vous pouvez utiliser la commande: <code>adduser</code>.</p><p>Pour supprimer un utilisateur, vous pouvez utiliser la commande: <code>deluser</code>.</p><p>La plupart des manipulation d'utilisateur nécessite les droits de root. Il faut donc utiliser la commande sudo pour les lancer (exemple <code>sudo adduser hulk</code>).</p><p>Une autre notion importante est celle de groupe. Un groupe est un ensemble d'utilisateurs qui partagent les mêmes fichers et répertoires. Chaque utilisateur doit faire partie au moins d'un groupe, son groupe primaire. Celui-ci est défini au moment de la création du compte, et par défaut, l'utilisateur appartient à un nouveau groupe créé, portant son nom.</p><p>L'appartenance au groupe primaire n'étant pas exclusive, tout utilisateur peut faire partie de plusieurs autres groupes, appelés ses groupes secondaires.</p><p>Pour lister tous les groupes (primaire et secondaires) d'un utilisateur : <code>groups nom_d_utilisateur</code> (exemple: <code>groups student</code>)</p><p>Pour créer un nouveau groupe: <code>groupadd avengers</code></p><p>Pour supprimer un groupe: <code>groupdel avengers</code></p><p>Pour ajouter un utilisateur à un groupe: <code>adduser hulk avengers</code></p><p>La commande <code>usermod</code> permet de faire plein d'opérations sur les utilisateurs et les groupes. Les options <code>-a</code>, <code>-g</code> et <code>-G</code> s'intéressent plus particulièrement aux groupes.</p><p>Essayez ces manipulations:</p><ul><li>Créer quelques utilisateurs</li><li>Effectuer des vérifications : possibilité immédiate de se loguer sous ces comptes, création de leur répertoire personnel dans <code>/home</code>.</li><li>Essayer de créer un compte déjà existant.</li><li>Supprimer sans regret le compte d'un utilisateur. Son répertoire personnel a t-il été supprimé ?</li><li>Essayer d'accéder au répertoire personnel d'un autre utilisateur.</li></ul></section><section><h1>Gestion des processus</h1><p>Les systèmes d'exploitation modernes sont capables de donner l'impression que plusieurs programme tournent en même temps sur un noyau de processeur en passant rapidement d'un programme à l'autre</p><p>Sous linux, les processus sont ces différents programmes qui s'exécutent "en même temps".</p><section><h1>Monitorer les processus</h1><p>Chaque processus a un processus parent. Ils sont donc liés par une structure arborescente. Le processus racine s'appelle <code>init</code>.</p><p>Chaque processus a également un <code>PID</code> (Process ID). Les <code>PID</code> sont assigné dans l'ordre à partir de 1 (pour le processus <code>init</code>)</p><p>Pour voir les processus, on utilise la commande <code>ps</code>.</p><pre class="console">$ ps
	PID   TTY      TIME CMD
	5198  pts/1    00:00:00 bash
	10129 pts/1    00:00:00 ps</pre><p>Dans cet exemple, on peut voir deux processus: <code>bash</code> est notre shell et <code>ps</code> est la commande que l'on vient de lancer. La colonne <code>TTY</code> indique à quel terminal est lié le processus. La colonne <code>TIME</code> indique le temps processeur que consomme le processus. Ici les deux processus ne font pas beaucoup travailler le processeur. On ne voit ici que les processus de l'utilisateur courant lié au terminal courant.</p><p>Si on ajoute l'option <code>x</code> <em>(attention: sans tiret)</em> à la commande, on obtient plus de résultat:</p><pre class="console">$ ps x
	PID   TTY     STAT   TIME COMMAND
	2799  ?       Ssl    0:00 /usr/libexec/bonobo-activation-server –ac
	2820  ?       Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
	15647 ?       Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
	15751 ?       Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
	15754 ?       Sl     0:01 /usr/libexec/evolution-data-server-1.10 --
	15755 ?       S      0:00 /usr/bin/dbus-launch --exit-with-session
	15774 ?       Ss     0:01 /bin/dbus-daemon --fork --print-pid 4 –pr
	15793 ?       Ss     0:02 /usr/bin/gpg-agent -s –daemon
	15794 ?       S      0:00 start_kdeinit --new-startup +kcminit_start
	15797 ?       Ss     0:00 kdeinit Running...
	
	et plus encore...</pre><p>Cette option montre tous les processus de l'utilisateur courant de tous les terminaux. Le <code>?</code> indique qu'aucun terminal ne contrôle ce processus. La colonne <code>STAT</code> indique le statut des processus. Les status possible sont:</p><ul><li><code>R</code>: Running, le processus s'exécute ou est près à s'exécuter.</li><li><code>S</code>: Sleeping, le processus attend un événement (une pression d'une touche, un paquet réseau, ...)</li><li><code>D</code>: Uninterruptible sleep, le processus attend une entrée/sortie comme le disque dur.</li><li><code>T</code>: Stopped, le processus a été arrêté.</li><li><code>Z</code>: Zombie, le processus est terminé mais n'a pas été nettoyé par son processus parent.</li><li><code>&lt;</code>: C'est un processus à haute priorité. Il recevra plus de temps CPU que les autres.</li><li><code>N</code>: C'est un processus a basse priorité.</li></ul><p>La deuxième lettre du status indique différentes autres caractéristiques que peuvent avoir les processus (voir <code>man ps</code>).</p><p>La commande <code>ps</code> est souvent appelé avec l'ensemble d'options aux qui donne encore plus d'information et qui donne les processus de tous les utilisateurs.</p><pre class="console">$ ps aux
	USER    PID %CPU %MEM     VSZ   RSS TTY      STAT START   TIME COMMAND
	root      1  0.0  0.0    2136   644 ?        Ss   Mar05   0:31 init
	root      2  0.0  0.0       0     0 ?        S<   Mar05   0:00 [kt]
	root      3  0.0  0.0       0     0 ?        S<   Mar05   0:00 [mi]
	root      4  0.0  0.0       0     0 ?        S<   Mar05   0:00 [ks]
	root      5  0.0  0.0       0     0 ?        S<   Mar05   0:06 [wa]
	root      6  0.0  0.0       0     0 ?        S<   Mar05   0:36 [ev]
	root      7  0.0  0.0       0     0 ?        S<   Mar05   0:00 [kh]
	
	et plus encore...</pre><p>Les colonnes indiquent:</p><ul><li><code>USER</code>: Le propriétaire du processus.</li><li><code>%CPU</code>: Utilisation du CPU en %.</li><li><code>%MEM</code>: Utilisation de la mémoire en %.</li><li><code>VSZ</code>: Mémoire virtuelle utilisée.</li><li><code>RSS</code>: Resident Set Size, la quantité de mémoire physique utilisée en kilobyte.</li><li><code>START</code>: Heure de démarrage du processus.</li></ul><p>Une autre commande permettant de consulter les processus en cours est la commande <code>top</code>. Cette commande est dynamique et permet de suivre l'évolution des processus. Cette commande permet aussi d'effectuer certaine action en utilisant les touche du clavier. La touche "q" permet de quitter et la touche "h" affiche l'aide que vous pouvez consulter pour connaitre les autres possibilités.</p></section><section><h1>Contrôler les processus</h1><p>Maintenant que l'on sait monitorer les processus, nous allons voir comment agir sur eux.</p><p>Pour faire des tests nous allons lancer un processus qui ne fait rien en tapant la commande <code>sleep infinity</code>. On constate, après avoir valider la commande, que le shell attend qu'elle se termine avant de nous permettre d'entrer une nouvelle commande. Comme la commande <code>sleep infinity</code> ne s'arrête jamais, l'invite de commande ne reviendra pas si on ne fait rien.</p><p>En fait le processus bloque notre shell car il a été lancé "à l'avant plan". Les processus lancé "en arrière plan" ne bloque pas le shell. Pour arrêter un processus lancé à l'avant plan on peut utiliser le raccourci <code>Ctrl-C</code>.</p><p>Pour lancer un programme en arrière plan, il suffit d'ajouter un &amp; à la fin de la commande</p><pre class="console">$ sleep infinity &amp;
	[1] 28236
	$</pre><p>Le shell nous informe du numéro de job 1 et du <code>PID</code> 28236 du programme lancé en arrière plan. Si on utilise <code>ps</code> on peut voir le processus dans la liste:</p><pre class="console">$ ps
	PID   TTY     TIME CMD
	10603 pts/1   00:00:00 bash
	28236 pts/1   00:00:00 sleep
	28239 pts/1   00:00:00 ps</pre><p>Pour voir les jobs lancé par le terminal en cours, on utilise la commande <code>jobs</code>.</p><p>Pour passer un processus de l'arrière plan au premier plan, on utilise la commande <code>fg</code> (foreground) suivie du numéro de job lui-même précédé d'un signe <code>%</code></p><pre class="console">$ fg %1
	sleep infinity</pre><p>Il suffit alors de taper <code>Ctrl-C</code> pour terminer le processus.</p><p>Pour mettre un processus au premier plan en pause, on utilise <code>Ctrl-Z</code>. Vous pouvez essayer avec la commande sleep infinity.</p><pre class="console">$ sleep infinity
	[1]+ Stopped               sleep infinity
	$</pre><p>Pour reprendre le processus en pause, on utilise la commande <code>fg</code> pour le reprendre au premier plan, et la commande <code>bg</code> pour le reprendre à l'arrière plan.</p><p>Pour terminer un processus, on utilise la commande <code>kill</code>. Le processus sont censé se terminer d'eux-même mais il arrive parfois qu'il faille le faire manuellement quand les choses se passent mal. La commande <code>kill</code> s'utilise avec le <code>PID</code> du processus.</p><pre class="console">[me@linuxbox ~]$ sleep infinity &amp;
	[1] 28401
	[me@linuxbox ~]$ kill 28401
	[1]+ Terminated            sleep infinity</pre><p>En realité, la commande <code>kill</code> ne sert pas uniquement à terminer un processus. Elle sert à envoyer des signaux aux processus. En fait lorsqu'on utilise les raccourcis <code>Ctrl-C</code> ou <code>Ctrl-Z</code> on envoie aussi des signaux au processus au premier plan. <code>Ctrl-C</code> lance le signal <code>INT</code> (Interrupt) et <code>Ctrl-Z</code> lance le signal <code>TSTP</code> (Terminal SToP). Par défaut, la commande <code>kill</code> lance le signal <code>TERM</code> (Terminate). Il existe un signal spécial, <code>KILL</code> qui termine un processus qui refuse d'écouter les autre signaux. Le signal <code>KILL</code> doit être utiliser en dernier recours car il ne permet pas au processus de se terminer "proprement".</p><p>Pour envoyer un signal particulier avec la commande <code>kill</code> on l'ajoute comme une option. Les signaux peuvent être mentionné avec leurs acronymes ou par un numéro. Vous pouvez trouver tous les signaux en tapant la commande <code>kill -l</code>.</p><pre class="console">$ sleep infinity &amp;
	[1] 28401
	$ kill -INT 28401
	[1]+ Interrupt            sleep infinity</pre><p>Vous pouvez aussi explorer (avec <code>man</code>) les commandes <code>pstree</code>, <code>vmstat</code> et <code>tload</code> qui permettent d'obtenir des informations sur les processus ou sur le niveau de charge du système.</p></section></section><section><h1>Gestion des disques</h1><p>Il arrive souvent qu'un ordianteur ai plusieurs disques. Il peut y avoir plusieurs disques durs mais également des clé USB ou des disques optiques.</p><p>Sous Linux, tous les disques sont regroupés au sein de la même arborescence et chaque disque s'y trouve donc à un certain endroit. On dit qu'on <strong>monte</strong> un disque lorsqu'on lui associe un emplacement dans l'arborescence du système de fichiers. LE contenu du disque devient alors accessible au système Linux.</p><section><h1>Le fichier <code>/etc/fstab</code></h1><p>Le fichier <code>/etc/fstab</code> liste les disques montés au démarrage du système.</p><p>Voici un exemple de fichier <code>fstab</code>:</p><pre class="console">UUID=383a2d6c-016a-4cdf-bca0-d10e7a6ec95f  /     ext4  errors=remount-ro  0  1
	UUID=aca23f27-be91-4a09-bf94-4c358e2b9cc7  none  swap  sw                 0  0</pre><p>Les colonnes sont:</p><ul><li>Le périphérique de stockage: Ce champ indique le périphérique qui sera monté. Traditionellement, on désignait les disques par le nom du fichier de périphérique qui lui est associé. En effet, sous Linux, chaque périphérique reconnu par le système possède un fichier dans le répertoire <code>/dev</code> (device). Les interactions avec un périphérique peuvent alors se faire en faisant des lectures et des écritures sur son fichier. Par exemple, le fichier représentant la première partition du disque maitre sur le premier canal IDE est <code>/dev/hda1</code>. Cette manière d'indentifier les disques est problématique car elle dépend de la façon dont les disques sont connectés au système. Il est donc aujourd'hui possible d'identifier les disques par un label (valeur spécifiée lors du formatage de la partition) ou un UUID (Universal Unique IDentifier).</li><li>Point de montage: l'emplacement, dans l'arborescence du système, où le disque sera monté.</li><li>Système de fichier: Il existe plusieurs système de fichier. Exemples: FAT32, NTFS, Ext3, Ext4, ...</li><li>Options: Il est possible de spécifier plusieurs options lors du montage d'un disque. On peut, par exemple, le monter en lecture seule.</li><li>Backup: Ce nombre spécifie si le disque doit être sauvegarder avec la commande <code>dump</code></li><li>Ordre: Ce nombre spécifie dans quel ordre les disques doivent être vérifié par la commande <code>fsck</code></li></ul><p>Pour voir la liste des disques actuelement montés, on peut utiliser la commande <code>mount</code> sans arguments.</p></section><section><h1>Monter un périphérique de stockage</h1><p>Sur les oridnateurs de bureau sous Linux, la plupart des périphériques de stockage sont montés automatiquement. Ce n'est malheureusement pas le cas sur tous les serveurs. Alors comment faire pour utiliser une clé USB sur un système qui ne la monte pas automatiquement?</p><p>La première chose à faire est de trouver le nom de son fichier dans <code>/dev</code>. Pour cela, nous pouvons utiliser la commande <code>sudo tail -f /var/log/syslog</code> avant de brancher le clé USB. Cette commande nous affiche les dernières lignes du fichier <code>/var/log/syslog</code> en live. C'est un fichier très interessant à observer lorsqu'on veut examiner ce que fait le système en presque temps réel.</p><p>Lorsqu'on branchera la clé, de nouvelle ligne devrait aparaitre sur le fichier <code>syslog</code>:</p><pre class="console">Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] 31263 512-byte hardware sectors (16 MB)
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] Write Protect is off
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] Assuming drive cache: write through
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] 31263 512-byte hardware sectors (16 MB)
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] Write Protect is off
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] Assuming drive cache: write through
	Aug 24 07:29:42 sy3t kernel: sdb: sdb1
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: [sdb] Attached SCSI removable disk
	Aug 24 07:29:42 sy3t kernel: sd 3:0:0:0: Attached scsi generic sg3 type 0</pre><p>Les multiples référence à <code>sdb</code> et la ligne <code>sdb:sdb1</code> nous indique que le fichier de la clé USB est <code>/dev/sdb</code> et que celui de sa partition est <code>/dev/sdb1</code>.</p><p>Il ne nous reste plus qu'à monter la clé à un emplacement de l'arborescence de fichier.</p><pre class="console">$ sudo mkdir /mnt/usb
	$ sudo mount /dev/sdb1 /mnt/usb
	$ df</pre><p>La commande <code>df</code> nous permet de vérifier l'espace libre/utilisé sur les disques montés. Elle nous permettra donc de voir que la clé a bien été montée et l'état d'occupation de son espace.</p><p>Pour démonter un disque, on utilise la commande <code>umount</code>. Dans notre cas: <code>umount /dev/sdb1</code></p><p>Voici quelques autres commandes interessantes concernant les disques:</p><ul><li><code>fdisk</code>: Permet de créer/modifier les partitions d'un disque</li><li><code>mkfs</code>: Permet de formater une partition avec un système de fichiers</li><li><code>fsck</code>: Permet de vérifier et réparer un système de fichier. (What the fsck !)</li><li><code>dd</code>: Permet de copier les blocks brutes (indépendamment du système de fichier) d'un disque. Cette commande peut avoir des conséquences catastrophiques (<code>dd</code> veut dire Data Definition mais est souvent appelée Destroy Disk)</li></ul></section></section><section><h1>Gestion du réseau</h1><p>La première commande à connaitre concernant le réseau est la commande <code>ping</code>. Elle permet d'envoyer un paquet à une machine du réseau et, si la machine répond, d'obtenir des statistiques sur la connexion entre les deux machines. <code>ping</code> prend comme paramètre, l'adresse IP ou le nom DNS de la cible des paquets. Par défaut, cette commande envoie des paquets en continu.</p><p>Pour obtenir plus d'information sur la connexion entre deux machines, on peut utiliser la commande <code>traceroute</code> qui affichera les différents routeurs par lesquels passent les paquets.</p><p>Pour connaitre la configuration des différentes interfaces réseaux du système, on peut utiliser la commande <code>ifconfig</code></p><p>La configuration des interfaces réseaux se fait dans le fichier <code>/etc/network/interfaces</code>:</p><pre class="console"># The loopback network interface
	auto lo
	iface lo inet loopback
	
	#The primary network interface
	auto eth0
	iface eth0 inet dhcp</pre><p>La ligne <code>iface eth0 inet dhcp</code> nous indique que l'adresse IP du système est obtenue automatiquement par DHCP. Si nous voulons donner une IP manuellement, nous la remplacerions par:</p><pre class="console">iface eth0 inet static
	  address 192.168.1.2
	  netmask 255.255.255.0
	  gateway 192.168.1.1
	  dns-nameservers 8.8.8.8 8.8.4.4</pre><p>La commande <code>wget</code> permet de télécharger un fichier d'internet. Il suffit de mettre l'URL en paramètre.</p><p><code>w3m</code> permet de surfer en mode texte.</p><p>La commande <code>curl</code> permet d'effectuer des requêtes dans tout une série de protocoles. C'est une commande très puissante. La syntaxe dépend du protocole utilisé.</p><p>Il est possible de se connecter à une autre machine à distance avec la commande <code>ssh</code>. Cette commande prend en paramètre l'IP ou le nom DNS de la machine à laquelle on souhaite se connecter. Pour fonctionner, il faut le que le système cible execute un serveur SSH (Le serveur SSH peut être installé sur Ubuntu avec la commande <code>sudo apt-get install ssh</code>). Par defaut, <code>ssh</code> essaye de se connecter avec le même nom d'utilisateur que sur le système local. Pour se connecter avec un autre nom d'utilisateur, on le mentionne avec un <code>@</code>:</p><pre class="console">$ ssh hulk@192.168.1.2</pre><p>Par défaut, vous devrez taper le mot de passe du compte auquel vous essayez de vous connecter. On peut également utiliser une clé SSH pour augmenter le niveau de sécurité et ne plus à avoir à taper de mot de passe. Nous en reparlerons prochainement.</p><p>On peut aussi copier un fichier par SSH avec la commande <code>scp</code>. Avec cette commande, il est possible d'envoyer un fichier à une autre machine, de récupérer un fichier sur une autre machine et même de copier un fichier d'une machine distante à une autre.</p></section><section><h1>Clé SSH</h1><p>Lorsqu'on utilise le programme ssh, celui-ci nous demande de taper notre mot de passe. Cependant il existe un autre moyen d'authentification plus pratique et sécurisé, les clés ssh. Les clés SSH vont par paire, une clé privée et une clé publique. Le principe des clés privée et publiques fonctionne comme suit: La clé privée ne doit jamais étre communiquée. La clé publique peut être donnée à n'importe qui. Cette clé publique sert à chiffrer des messages qui ne pourront être déchiffrés qu'avec la clé privée. Donc, si quelqu'un veut vous envoyer un message chiffré, il se procure votre clé publique, il chiffre le message avec et vous envoie le message chiffré. Vous seul pourrez le déchiffrer car vous êtes le seul à connaitre votre clé privée. SSH utilise un mecanisme similaire pour assurer une communication sécurisée lors des communication avec l'ordinateur distant.</p><section><h1>Générer une paire de clé</h1><p>Nous allons maintenant essayer de nous connecter à notre ubuntu virtuel à partir du système d'exploitation hôte en utilisant des clés SSH. Pour que cela soit possible, l'ordinateur virtuel à 2 cartes réseaux. Vous pouvez voir les adresses des deux carte en tapan la commande <code>ifconfig</code>. Une des carte sert à accéder au monde extérieur (hors OS hôte) et à 10.0.2.15 comme adresse IP. La deuxième est en réseaux privé avec l'hôte et à une adresse différente. Ces cette dernière adresse que vous pouvez utilisé pour vous connecter à la machine virtuelle (VM) à partir de l'hôte. Vous pouvez dès à présent essayer de vous connecter à la VM en tapant ceci dans un terminal (utiliser git-bash si vous êtes sur windows):</p><pre class="console">$ ssh student@X.X.X.X</pre><p>Utilisez l'adresse IP de la VM sur le réseau privé à la place de X.X.X.X. et vous devriez pouvoir vous connecter sans problème.</p><p>Pour le moment l'interface reliée au réseau privé reçoit son adresse IP par DHCP. Il pourrait être interessant de rendre cette IP statique pour pouvoir toujours ce connecter avec la même IP (cf séance précédente).</p><p>Pour deconnecter il suffit de taper <code>exit</code>.</p><p>Pour pouvoir nous connecter avec des clé SSH, il faut d'abord en créer. Nous allons les créer sur l'hôte car c'est à partir de lui que nous voulons nous connecter.</p><p>Dans un terminal (git-bash pour Windows), tapez la commande:</p><pre class="console">$ ssh-keygen -t rsa  -b 4096 -C "votre_email@exemple.com"</pre><p>Il vous est ensuite demandé où vous voulez sauver la clé. L'emplacement par default (<code>~/.ssh/id_rsa</code>) est idéal mais si vous possédez déjà une clé SSH, il est possible que vous vouliez changer le nom du fichier. Si vous allez voir à l'emplacement en question, vous verez que deux fichiers ont été créés: <code>id_rsa</code> et <code>id_rsa.pub</code> (en admettant que vous avez garder le nom par défaut). La clé publique est dans le fichier <code>.pub</code> et la clé privée dans l'autre.</p><p>On vous demande ensuite de taper une passphrase. Il s'agit d'un mot de passe qui protège votre clé privée.</p><p>Pour ne pas devoir taper la passphrase à chaque connexion, il faut ajouter la clé privée au <code>ssh-agent</code>. Pour cela, il faut d'abord démarrer le ssh-agent. tapez la commande:</p><pre class="console">$ eval $(ssh-agent -s)</pre><p>Pour ajouter la clé privée au ssh-agent, il suffit de taper:</p><pre class="console">$ ssh-add ~/.ssh/id_rsa</pre><p>N'oubliez pas de changer le nom du fichier si vous n'avez pas utiliser la valeur par défaut.</p></section><section><h1>Envoyer la clé publique sur la VM</h1><p>Pour pouvoir nous connecter à la VM avec nos clés SSH, il faut qu'elle connaisse notre clé publique. Pour cela il faut que la clé publique soit listée dans le fichier <code>/home/student/.ssh/autorized_keys</code>. Commencez donc par créer le fichier <code>~/.ssh/authorized_keys</code> sur votre VM s'il n'existe pas. Envoyez ensuite votre fichier <code>.pub</code> sur la VM avec la commande <code>scp</code>:</p><pre class="console">$ scp ~/.ssh/id_rsa.pub student@X.X.X.X:/home/student/.ssh</pre><p>Puis sur la VM recopiez le contenu du fichier <code>.pub</code> dans <code>authorized_keys</code>:</p><pre class="console">$ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
</pre></section><section><h1>Se connecter avec les clé SSH</h1><p>Pour nous connecter à la VM avec nos clé SSH il suffit de taper:</p><pre class="console">$ssh -i ~/.ssh/id_rsa student@X.X.X.X</pre><p>L'option <code>-i</code> sert à spécifier la clé privée à utiliser. Par defaut, SSH utilise déjà <code>~/.ssh/id_rsa</code> donc si vous avez utiliser les valeurs par defaut, vous pouvez vous contenter de</p><pre class="console">$ssh student@X.X.X.X</pre><p>Si vous avez choisi un autre nom de fichier et que vous ne voulez pas écrire l'option <code>-i</code> à chaque fois, vous pouvez créer un fichier de configuration SSH (<code>~/.ssh/config</code>) sur l'hôte contenant:</p><pre class="console">Host X.X.X.X
 IdentityFile ~/.ssh/autre_rsa</pre><p>Ce fichier de config peut également stocker le nom d'utilisateur à utiliser pour la connexion et un alias pour le serveur:</p><pre class="console">Host vm
 HostName X.X.X.X
 User student
 IdentityFile ~/.ssh/autre_rsa</pre><p>On peut alors se connecter simplement avec</p><pre class="console">$ ssh vm</pre></section><section><h1>Les clé SSH sur Github</h1><p>Github vous permet aussi de vous cannecter avec ssh. Pour cela il faut renseigner votre clé SSH dans les paramètre de votre compte Github et d'utiliser le lien SSH du projet que vous voulez cloner.</p><p>Les liens Github SSH commence par <code>git@github.com:</code> alors que les liens sans SSH commence par <code>https://github.com/</code>.</p></section></section><section>Installer des paquets<p>Dans la plupart des des distribution Linux il existe un gestionnaire de paquets qui sert à installer des logiciels supplémentaires au système. Sur ubuntu le gestionnaire de paquet s'appelle <code>apt</code>.</p><p>Pour installer un logiciel (<code>python3</code> ici) tapez:</p><pre class="console">$ sudo apt-get install python3</pre><p>Comme l'installation nécessite les droits administrateur il faut utiliser la commande <code>sudo</code>.</p><p>Pour faire une recherche parmi les paquets disponibles, on utilise:</p><pre class="console">$ apt-cache search truc_à_chercher</pre><p>Les paquets installables sont en réalité stockés sur des serveurs. Les adresses des serveurs de paquets (appelés dépots) se trouvent dans le fichier <code>/etc/apt/sources.list</code>. La commande <code>apt-cache</code> ne cherche pas directement sur les serveurs mais dans une copie local de la liste des paquets. Pour mettre à jour cette liste locale il faut utiliser la commande <code>sudo apt-get update</code>.</p><p>On peut également mettre à jour les paquets installé sur le système. Pour cela, on utilise la commande:</p><pre class="console">$ sudo apt-get upgrade</pre><p>Idéalement, on fait d'abord une mise à jour de la liste des paquets pour que toutes les mise à jours disponibles soient installées.</p><p>Il est bien entendu possible de désinstaller un paquet. La commande <code>sudo apt-get remove nom_du_paquet</code></p><p>permet de le faire mais ne supprime pas les fichiers de configuration associés au paquet. Pour tout supprimer on utilisera <code>sudo apt-get purge nom_du_paquet</code>.</p><p>Comme exercices mettez à jour le système et installez les paquets <code>python3-pip</code>, <code>nodejs-legacy</code> et <code>npm</code>.</p></section><section><h1>Créer un simple serveur web</h1><p>Un serveur web est un serveur qui fait tourner un service capable de répondre à des requête HTTP. Comme nous avons déjà un serveur, nous allons essayer maintenant de créer un service web.</p><p>Un service est un programme tournant en arrière plan. Nous devons donc nous arranger pour créer un programme qui réponde à des requêtte HTTP et il ne nous restera plus qu'à le lancer en arrière plan.</p><p>Nous savons déjà créer un programme qui réponde à des requête web en Python avec le module bottle. Installons donc ce module en utilisant le gestionnaire de paquet de python, <code>pip3</code> que nous avons installer un peu plus tôt:</p><pre class="console">$ sudo pip3 install bottle</pre><p>nous pouvons ensuite créer un petit programme simple comme celui-ci:</p><pre class="console">from bottle import route, run

@route('/hello')
def hello():
  return "Hello wordl !"

run(host=0.0.0.0, port=8080)</pre><p>Le programme pourrait être sauvé dans un fichier nommé <code>web.py</code>. Et nous pouvons le lancer en arrière plan avec <code>python3 web.py &</code>.</p><p>Nous pouvons maintenant tester le serveur en essayant d'accéder au site avec le navigateur de l'OS hôte (<code>http://X.X.X.X/hello</code>).</p><section><h1>Démarrage automatique avec Systemd</h1><p>Notre serveur est très bien mais si l'ordinateur redémarre, il faut relancer manuellement le service web. Ce n'est pas très pratique. Il existe plusieurs moyens de créer un <strong>vrai</strong> service qui démarre automatiquement au démmarage de l'ordinateur. Nous allons comment utiliser Systemd qui est le moyen conseillé sur Ubuntu.</p><p>Nous allons commencer par deplacer notre programme python dans le répertoire <code>/srv</code>. Comme c'est le système qui va démarrer le programme avant même que nous nous connections, il est plus logique que ce programme ne soit plus dans notre répertoire personnel.</p><p>Nous devons ensuite créer le fichier de configuration de notre service: <code>/etc/systemd/system/hello.service</code></p><p>Et nous allons y écrire le contenu suivant:</p><pre class="console">[Unit]
Description=Python Hello Web Server
After=network.target

[Service]
ExecStart=/usr/bin/python3 /srv/web.py

[Install]
WantedBy=default.target</pre><p>Systemd ne s'occupe pas que de services, les entités qu'il gere sont appelées unité. La première section du fichier (Unit File) est la section <code>Unit</code> qui décrit l'unité.</p><p>La propriété <code>After</code> nous indique que cette unité doit être démarée après que le réseaux soit démarré.</p><p>La section <code>Service</code> sontient des propriété spécifique aux unité de type service. La propriété <code>ExecStart</code> contient la commande à exécuter lorsque le service est démarré. Remarquez qu'on utilise les chemins absolus pour les commandes et les fichiers.</p><p>La section <code>Install</code> spécifie comment l'unité doit être activée. Dans ce cas, Elle sera listée dans les unités demandée par l'unité <code>default.target</code>. Cela signifie que le demarrage de notre unité sera pris en considération au moment où l'unité <code>default.target</code> sera démarré.</p><p>Il faut notifier systemd qu'une nouvelle unité est disponible puis activé notre unité:</p><pre class="console">$ sudo systemctl daemon-reload
$ sudo systemctl enable hello.service</pre><p>Si nous redemarrons le serveur (<code>sudo reboot</code>) nous constaterons que notre service à bien été démarré.</p><p>Nous pouvons obtenir des informations sur le service avec la commande <code>sudo systemctl status hello.service</code></p></section></section><script>/* http://prismjs.com/download.html?themes=prism&languages=markup+css+clike+javascript+python */
	var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
	Prism.languages.markup={comment:/<!--[\w\W]*?-->/,prolog:/<\?[\w\W]+?\?>/,doctype:/<!DOCTYPE[\w\W]+?>/,cdata:/<!\[CDATA\[[\w\W]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=.$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,inside:{punctuation:/[=>"']/}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
	Prism.languages.css={comment:/\/\*[\w\W]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^\{\}\s][^\{\};]*?(?=\s*\{)/,string:/("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,property:/(\b|\B)[\w-]+(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.util.clone(Prism.languages.css),Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css"}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|').*?\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
	Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
	Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,number:/\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,"function":/[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i}),Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^\/])\/(?!\/)(\[.+?]|\\.|[^\/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,lookbehind:!0,greedy:!0}}),Prism.languages.insertBefore("javascript","class-name",{"template-string":{pattern:/`(?:\\\\|\\?[^\\])*?`/,greedy:!0,inside:{interpolation:{pattern:/\$\{[^}]+\}/,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:"language-javascript"}}),Prism.languages.js=Prism.languages.javascript;
	Prism.languages.python={"triple-quoted-string":{pattern:/"""[\s\S]+?"""|'''[\s\S]+?'''/,alias:"string"},comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},string:{pattern:/("|')(?:\\\\|\\?[^\\\r\n])*?\1/,greedy:!0},"function":{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)[a-z0-9_]+/i,lookbehind:!0},keyword:/\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,"boolean":/\b(?:True|False)\b/,number:/\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,punctuation:/[{}[\];(),.:]/};
	!function(e){var t={variable:[{pattern:/\$?\(\([\w\W]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\w\W]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[a-z0-9_#\?\*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)(?:"|')?(\w+?)(?:"|')?\s*\r?\n(?:[\s\S])*?\r?\n\2/g,lookbehind:!0,greedy:!0,inside:t},{pattern:/(["'])(?:\\\\|\\?[^\\])*?\1/g,greedy:!0,inside:t}],variable:t.variable,"function":{pattern:/(^|\s|;|\||&)(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|\s|;|\||&)/,lookbehind:!0},keyword:{pattern:/(^|\s|;|\||&)(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|\s|;|\||&)/,lookbehind:!0},"boolean":{pattern:/(^|\s|;|\||&)(?:true|false)(?=$|\s|;|\||&)/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var a=t.variable[1].inside;a["function"]=e.languages.bash["function"],a.keyword=e.languages.bash.keyword,a.boolean=e.languages.bash.boolean,a.operator=e.languages.bash.operator,a.punctuation=e.languages.bash.punctuation}(Prism);</script></body></html>