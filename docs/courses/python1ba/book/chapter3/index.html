<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 3 - Séquences</title>
    <script src="/document.js" defer></script>
    
</head>
<body>
    <h1>Chapitre 3 <small>Séquences</small></h1>
    
    <script type="module" defer>
Doc.setChapterNb(3)
</script>

<p>Les séquences sont des structures de données ordonnées, c&#39;est-à-dire, des suites de données individuelles rangées dans un ordre bien déterminé. Pour prendre un exemple, les chaînes de caractères sont des séquences. En effet, une chaine de caractères est une suite de caractères (les données) rangés dans un ordre déterminé (la chaine <code>&quot;python&quot;</code> n&#39;est pas équivalente à <code>&quot;yphtno&quot;</code>).</p>
<p>En Python, les chaines de caractères ne sont pas les seules séquences. Dans ce chapitre, nous allons voir les listes, les tuples et les intervalles et nous verrons qu&#39;elles partagent beaucoup de fonctionnalités avec les chaînes de caractères.</p>
<h2>Les listes</h2>
<p>Les valeurs de type liste sont des valeurs qui peuvent contenir une liste de valeurs&nbsp;:</p>
<pre><code class="language-python">nombres = [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>Dans l&#39;exemple ci-dessus, nous avons une variable nombres qui contient 7 entiers. Les listes peuvent aussi contenir des valeurs de différents types&nbsp;:</p>
<pre><code class="language-python">mix = [&#39;truc&#39;, 3.141592, 1234, [&#39;hello&#39;, &#39;world&#39;]
</code></pre>
<p>On peut voir dans l&#39;exemple ci-dessus qu&#39;une même liste peut contenir des chaines de caractères, des entiers, des nombres à virgule flottante et même d&#39;autres listes.</p>
<h3>Accès aux éléments</h3>
<p>Il est possible d&#39;accéder aux éléments individuels en utilisant les <code>[]</code>&nbsp;:</p>
<pre><code class="language-python">print(nombres[1])      # affichera 2
nombres[6] = &#39;sept&#39;    # modifie l&#39;élément d&#39;indice 6
</code></pre>
<p>Les éléments sont numérotés à partir de zéro. On peut également utiliser des indices négatifs pour accéder aux éléments d&#39;une séquence en partant de la fin. Ainsi, l&#39;élément d&#39;indice <code>-1</code> est le dernier élément, l&#39;élément d&#39;indice <code>-2</code> est l&#39;avant-dernier élément, et ainsi de suite.</p>
<h3>Fonctions <code>len()</code> et <code>del()</code></h3>
<p>Comme pour les chaines de caractères, il est possible d&#39;obtenir la taille d&#39;une liste en
utilisant la fonction <code>len()</code>.</p>
<p>Pour supprimer un élément d&#39;une liste, on utilise la fonction <code>del()</code>&nbsp;:</p>
<pre><code class="language-python">del(nombres[3])
print(nombres) # affichera [1, 2, 3, 5, 6, &#39;sept&#39;]
             # 4 a été supprimé
</code></pre>
<h3>Les tranches</h3>
<p>Il est possible d&#39;extraire une partie d&#39;une séquence de la manière suivante&nbsp;:</p>
<pre><code class="language-python">j = nombres[2:5]
</code></pre>
<p>Dans le code ci-dessus, <code>j</code> contiendra <code>[3, 5, 6]</code>. La tranche <code>[m,n]</code> est une <strong>nouvelle liste</strong> contenant les éléments de l&#39;indice <code>m</code> inclus à l&#39;indice <code>n</code> exclu.</p>
<p>Si on omet la première des deux bornes (<code>nombres[:5]</code>), la tranche commencera au début de la liste originale. Si c&#39;est la fin qui est omise (<code>nombres[2:]</code>), la tranche ira jusqu&#39;à la fin de la liste originale.</p>
<p>On peut également remplacer une portion de liste par une autre&nbsp;:</p>
<pre><code class="language-python">nombres[2:5] = [&#39;toto&#39;, &#39;tata&#39;, &#39;tutu&#39;, &#39;titi&#39;]
</code></pre>
<p>Après l’instruction ci-dessus, la liste <code>nombres</code> contiendra [1, 2, ’toto’, ’tata’, ’tutu’, ’titi’, ’sept’].</p>
<p>Il est également possible d’ajouter des éléments de cette manière&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 5, 6]

L[2:2] = [3, 4]

# L vaut maintenant [1, 2, 3, 4, 5, 6]
</code></pre>
<p>Donc, pour ajouter un élément en début de liste, on procèderait comme suit&nbsp;:</p>
<pre><code class="language-python">L = [2, 3, 4]

L[:0] = [1]

# L vaut maintenant [1, 2, 3, 4]
</code></pre>
<p>Et, pour ajouter un élément en fin de liste, on procèderait comme suit&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 3, 4]

L[len(L):] = [5]

# L vaut maintenant [1, 2, 3, 4, 5]
</code></pre>
<h3>Méthodes</h3>
<p>Nous avons vu plus haut comment ajouter des éléments dans une liste en utilisant des assignations à des tranches. Bien que cette façon de modifier une liste soit très puissante, elle n&#39;est pas très pratique à utiliser pour des opérations simples et courantes comme l&#39;ajout en fin de liste.</p>
<p>En réalité il existe tout un tas de fonctionnalités associées au type <code>list</code>. l&#39;une d&#39;entre elle permet d&#39;ajouter un élément en fin de liste et s&#39;appelle <code>append</code>. Voici comment on l&#39;utilise&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 3, 4]
L.append(5)
# L vaut maintenant [1, 2, 3, 4, 5]
</code></pre>
<p>Vous pouvez voir que pour utiliser la fonctionnalités <code>append</code> des liste, on doit appeler la fonction <code>append()</code> attachée <em>(avec un <code>.</code>)</em> à la valeur de type <code>list</code> sur laquelle on souhaite appliquer la fonctionnalités.</p>
<p>On appelle ce genre de fonctionnalités des <strong>méthodes</strong></p>
<p>Nous n&#39;allons pas voir ici toutes les méthodes du type <code>list</code> mais nous allons quand même mentionner les méthodes <code>insert()</code> et <code>pop()</code>&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 4, 5]
L.insert(2, 3) # insère l&#39;élément 3 à l&#39;indice 2
# L vaut maintenant [1, 2, 3, 4, 5]

v = L.pop(2) # enlève et renvoie l&#39;élément d&#39;indice 2
# L vaut de nouveau [1, 2, 4, 5] et v contient 3
</code></pre>
<h3>Opérations</h3>
<h4>Concaténation</h4>
<p>Il est possible de créer une <strong>nouvelle séquence</strong> correspondant à la concaténation de deux séquences, c&#39;est-à-dire, de la mise bout à bout de ces deux séquences. Pour cela, on utilise l&#39;opération <code>+</code>.</p>
<pre><code class="language-python">L1 = [1, 2, 3]
L2 = [4, 5, 6]
L3 = L1 + L2   # L3 sera égal à [1, 2, 3, 4, 5, 6]

s1 = &#39;hello &#39;
s2 = &#39;world&#39;
s3 = s1 + s2   # s3 sera égal à &#39;hello world&#39;
</code></pre>
<h4>Répétition</h4>
<p>On peut également créer une <strong>nouvelle séquence</strong> correspondant à la répétition d&#39;une séquence en utilisant l&#39;opérateur <code>*</code>.</p>
<pre><code class="language-python">L1 = [1, 2, 3]
L2 = L1 ∗ 2    # L2 sera égal à [1, 2, 3, 1, 2, 3]

s1 = &#39;hello &#39;
s2 = s1 ∗ 3    # s2 sera égal à &#39;hello hello hello&#39;
</code></pre>
<h4>L&#39;opérateur <code>in</code></h4>
<p>L&#39;opérateur <code>in</code> renvoie <code>True</code> si l&#39;élément à sa gauche est dans la séquence à sa droite.</p>
<p>Pour vérifier si une valeur se trouve dans une liste, on peut utiliser l&#39;instruction <code>in</code> dans
un <code>if</code>&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 5, 6]
if 2 in L:
    print(&quot;2 est dans la liste&quot;)
else:
    print(&quot;2 n&#39;est pas dans la liste&quot;)
</code></pre>
<h3>L&#39;instruction <code>for … in …</code></h3>
<p>Pour effectuer un traitement sur tous les éléments d&#39;une séquence, il est bien sûr possible d&#39;utiliser une boucle <code>while</code>. Cependant, le Python prévoit une boucle <code class="nowrap">for … in …</code> permettant de le faire de façon plus pratique.</p>
<div class="row">
<div class="span5 middle">

<pre><code class="language-python">for variable in séquence:
    bloc_d_instruction
</code></pre>
</div>
<div class="span7">
<figure id='for_in' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>for … in …</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#for_in > div', 350, 400)
    const start = draw.start().move(1, 2)
    const init = draw.round('On démarre du premier élément de la liste').belowOf(start)
    const back = draw.dummy().belowOf(init)
    const cond = draw.round('l’élément existe-t-il ?').belowOf(back)
    const if1 = draw.diamond().belowOf(cond)
    const oui = draw.node('oui').belowOf(if1)
    const non = draw.node('non').rightOf(if1)
    const dummy = draw.dummy().leftOf(if1)
    const assign = draw.round('<code>variable</code> prend la valeur de l\'élément').belowOf(oui)
    const bloc = draw.round('exécution du <code>bloc_d_instructions</code>').belowOf(assign)
    const inc = draw.round('On passe à l\'élément suivant').belowOf(bloc)
    const end = draw.end().belowOf(inc)
    draw.polyline([start, '-->', init, '--', back, '-->', cond, '-->', if1, '--', oui, '-->', assign, '-->', bloc, '-->', inc, '-|', dummy, '|->', back])
    draw.polyline([if1, '--', non, '|->' , end])
    draw.done()
</script>
</div>
</div>

<p>Dans une boucle <code>for … in …</code>, la variable prend successivement la valeur de chaque élément de la liste.</p>
<p>Le code suivant&nbsp;:</p>
<pre><code class="language-python">L = [&#39;truc&#39;, &#39;machin&#39;, &#39;bidule&#39;]

for a in L:
    print(a)
</code></pre>
<p>affichera&nbsp;:</p>
<div class="terminal">
    truc
    machin
    bidule
</div>

<p>Dans le code ci-dessus, la variable <code>a</code> vaut <code>&#39;truc&#39;</code> au premier tour de boucle, <code>&#39;machin&#39;</code> au deuxième tour de boucle et <code>&#39;bidule&#39;</code> au troisième tour de boucle.</p>
<h3>Les copies</h3>
<p>Nous allons voir voir ici que l&#39;on peut facilement avoir des surprises lorsqu&#39;on essaye de faire une copie d’une liste.</p>
<p>Dans le code qui va suivre, nous allons essayer de créer une copie d&#39;une liste pour pouvoir modifier la copie tout en gardant l&#39;originale inchangée&nbsp;:</p>
<pre><code class="language-python">originale = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]   # liste originale
copie = originale                     # copie de l&#39;originale

copie[1] = &#39;love&#39;                     # modification de la copie

print(originale)                      # affichage de l&#39;originale
print(copie)                          # affichage de la copie
</code></pre>
<p>Ce qui affiche&nbsp;:</p>
<div class="terminal">
['I', 'love', 'Python']
['I', 'love', 'Python']
</div>

<p>On constate donc que les deux listes ont été modifiées et que l&#39;originale a été perdue. En effet, le fait d’écrire <code>copie = originale</code> ne crée pas de nouvelle liste.</p>
<p>En Python, comme dans beaucoup d&#39;autres langages de programmation, dès qu&#39;elle contient un type plus complexe qu&#39;un simple nombre, une variable ne contient pas directement sa valeur mais seulement une référence à celle-ci. Lorsqu&#39;on écrit <code>copie = originale</code> on ne fait une copie que de la référence. On se retrouve donc avec deux variables qui manipulent la même liste.</p>
<figure id='references' data-ref='figure'>
    <img src="./references.svg" class="half">
    <figcaption>Deux références pour la même liste</figcaption>
</figure>


<p>Ce système de référence existe car la copie de types complexes prend du temps et n&#39;est souvent pas souhaitable.</p>
<p>Pour créer une vraie copie de la liste, on peut utiliser un <em>slicing</em>&nbsp;:</p>
<pre><code class="language-python">originale = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]   # liste originale
copie = originale[:]                  # copie de l&#39;originale

copie[1] = &#39;love&#39;                     # modification de la copie

print(originale)                      # affichage de l&#39;originale
print(copie)                          # affichage de la copie
</code></pre>
<p>Ce qui affiche&nbsp;:</p>
<div class="terminal">
['I', 'like', 'Python']
['I', 'love', 'Python']
</div>


<p>Un <em>slicing</em> crée toujours une nouvelle liste. On obtient donc bien une vrai copie de l&#39;originale. Il existe d&#39;autres opérations que l&#39;on peut exploiter pour obtenir le même résultat&nbsp;:</p>
<pre><code class="language-python">copie = originale * 1
copie = originale + []
</code></pre>
<p>On peut aussi utiliser la fonction <code>list()</code> qui crée une liste à partir de ce qu&#39;on lui passe en paramètre&nbsp;:</p>
<pre><code class="language-python">copie = list(originale)
</code></pre>
<h2>Les chaînes de caractères</h2>
<p>Comme nous l&#39;avons déjà dit plus haut, les chaines de caractères et les liste partagent beaucoup de fonctionnalités&nbsp;:</p>
<pre><code class="language-python">s = &#39;Python&#39;

print(s[1])      # affiche &#39;y&#39;
print(len(s))    # affiche 6
print(s[1:3])    # affiche &#39;yt&#39;
print(s * 2)     # affiche &#39;PythonPython&#39;
print(&#39;I love &#39; + s) # affiche &#39;I love Python&#39;

for l in s:
    print(l)     # affiche :
                 # P
                 # y
                 # t
                 # h
                 # o
                 # n
</code></pre>
<p>Il y a bien sûr quelques différences.</p>
<h3>Opérateur <code>in</code></h3>
<p>L&#39;opérateur <code>in</code> fonctionne aussi avec les chaines de caractères&nbsp;:</p>
<pre><code class="language-python">if &quot;l&quot; in &quot;salut&quot;:
    print(&quot;&#39;l&#39; est une lettre de &#39;salut&#39;&quot;)
</code></pre>
<p>Mais il fonctionne aussi quand l&#39;opérande de droite est une sous-chaîne&nbsp;:</p>
<pre><code class="language-python">if &quot;al&quot; in &quot;salut&quot;:
    print(&quot;&#39;al&#39; est une sous-chaine de &#39;salut&#39;&quot;)
</code></pre>
<h3>Immuable</h3>
<p>Il y a une grande différence entre les listes et les chaines de caractères : les listes sont des séquences modifiables alors que les chaines de caractères sont des séquences <strong>non-modifiables</strong> ou <strong>immuable</strong>.</p>
<p>En gros, cela veut dire qu&#39;on peut modifier une liste&nbsp;:</p>
<pre><code class="language-python">L = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]
L[2] = &#39;love&#39;     # ceci fonctionne
</code></pre>
<p>Mais qu&#39;on ne peut pas modifier une chaine de caractères. Le code suivant ne fonctionne donc pas&nbsp;:</p>
<pre><code class="language-python">s = &quot;Le Python, c&#39;est bon !&quot;
s[17] = &quot;c&quot;       # ceci ne fonctionne pas !
</code></pre>
<p>La suppression et l&#39;insertion de caractères est également interdite pour les chaines de caractères.</p>
<p>Voyons maintenant le code suivant&nbsp;:</p>
<pre><code class="language-python">s = &quot;Le Python, c&#39;est bon !&quot;
s = s[:17] + &quot;cool&quot; + s[20:] # ceci fonctionne
</code></pre>
<p>Ce code affichera bien <code>Le Python, c&#39;est cool !</code>. Il semble donc que la chaine de caractères <code>s</code> ait bien été modifiée; puisque sa valeur était <code>&quot;Le Python, c&#39;est bon !&quot;</code> au départ. Mais en réalité, la chaine de départ n&#39;a pas changé. C&#39;est la référence dans la variable <code>s</code> qui a été remplacée. La somme <code>s[:17] + &quot;cool&quot; + s[20:]</code> crée une nouvelle chaine de caractères, indépendante de la chaine <code>&quot;Le Python, c&#39;est bon !&quot;</code> d’origine. La variable &#39;s&#39; contient ensuite une référence vers cette nouvelle chaine à cause de l&#39;assignation (<code>s =</code>). Du coup, plus aucune variable ne référence la chaine d&#39;origine ce qui provoquera son effacement de la mémoire.</p>
<h2>Les tuples</h2>
<p>Un tuple, comme une liste, est une suite de valeurs pouvant être de différents types. La grosse différence entre les listes et les tuples c&#39;est que les tuples sont <strong>immuables</strong>. Les éléments d&#39;un tuple ne peuvent pas être réassignés et on ne peut pas en ajouter ou en enlever.</p>
<p>Pour définir un tuple, on peut utiliser des parenthèses mais elle sont optionnelles&nbsp;:</p>
<pre><code class="language-python"># Tuple vide
a = ()

# Tuples contenant un seul élément
b = 1,
c = (1,)

# Tuples contenant trois éléments
d = 1, 2, 3
e = (1, 2, 3)
</code></pre>
<p>On remarque que pour le tuple à un seul élément, on est obligé de mettre une virgule à la fin. Sans cette virgule on ne saurait pas faire la différence entre une valeur et la même valeur seule dans un tuple.</p>
<h3>Déballage</h3>
<p>Tous comme il est possible d&#39;emballer plusieurs valeurs dans un tuple&nbsp;:</p>
<pre><code class="language-python">t = 1, 2, 3
</code></pre>
<p>Il est également possible de déballer un tuple dans plusieurs variables&nbsp;:</p>
<pre><code class="language-python">a, b, c = t
</code></pre>
<p>Il faut, bien entendu, qu&#39;il y ai autant de valeurs que de variables.</p>
<p>Lorsqu&#39;on combine un emballage avec un déballage on obtient <strong>une assignation multiple</strong>&nbsp;:</p>
<pre><code class="language-python">a, b, c = 1, 2, 3
</code></pre>
<h2>Les intervalles</h2>

</body>
</html>
