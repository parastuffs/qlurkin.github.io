<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 3 - Séquences</title>
    <script src="/document.js" defer></script>
    
</head>
<body>
    <h1>Chapitre 3 <small>Séquences</small></h1>
    
    <script type="module" defer>
Doc.setChapterNb(3)
</script>

<p>Les séquences sont des <strong>structures de données ordonnées</strong>, c&#39;est-à-dire, des suites de données individuelles rangées dans un ordre bien déterminé. Pour prendre un exemple, les chaînes de caractères sont des séquences. En effet, une chaine de caractères est une suite de caractères (les données) rangés dans un ordre déterminé (la chaine <code>&quot;python&quot;</code> n&#39;est pas équivalente à <code>&quot;yphtno&quot;</code>).</p>
<p>En Python, les chaines de caractères ne sont pas les seules séquences. Dans ce chapitre, nous allons voir les listes, les tuples et les intervalles. Nous verrons qu&#39;ils partagent beaucoup de fonctionnalités avec les chaînes de caractères.</p>
<h2>Les listes</h2>
<p>Les valeurs de type liste sont des valeurs qui peuvent <strong>contenir</strong> une liste de valeurs&nbsp;:</p>
<pre><code class="language-python">nombres = [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<p>Dans l&#39;exemple ci-dessus, nous avons une variable nombres qui contient 7 entiers. Les listes peuvent aussi contenir des valeurs de différents types&nbsp;:</p>
<pre><code class="language-python">mix = [&#39;truc&#39;, 3.141592, 1234, [&#39;hello&#39;, &#39;world&#39;]
</code></pre>
<p>On peut voir dans l&#39;exemple ci-dessus qu&#39;une même liste peut contenir des chaines de caractères, des entiers, des nombres à virgule flottante <strong>et même d&#39;autres listes</strong>.</p>
<h3>Accès aux éléments</h3>
<p>Il est possible d&#39;accéder aux <strong>éléments individuels</strong> en utilisant les <code>[]</code>&nbsp;:</p>
<pre><code class="language-python">print(nombres[1])      # affichera 2
nombres[6] = &#39;sept&#39;    # modifie l&#39;élément d&#39;indice 6
</code></pre>
<p>Les éléments sont numérotés <strong>à partir de zéro</strong>. On peut également utiliser des indices négatifs pour accéder aux éléments d&#39;une séquence en partant de la fin. Ainsi, l&#39;élément d&#39;indice <code>-1</code> est le dernier élément, l&#39;élément d&#39;indice <code>-2</code> est l&#39;avant-dernier élément, et ainsi de suite.</p>
<h3>Fonctions <code>len()</code> et <code>del()</code></h3>
<p>Comme pour les chaines de caractères, il est possible d&#39;obtenir la <strong>taille</strong> d&#39;une liste en
utilisant la fonction <code>len()</code>.</p>
<p>Pour <strong>supprimer</strong> un élément d&#39;une liste, on utilise la fonction <code>del()</code>&nbsp;:</p>
<pre><code class="language-python">del(nombres[3])
print(nombres) # affichera [1, 2, 3, 5, 6, &#39;sept&#39;]
             # 4 a été supprimé
</code></pre>
<h3>Les tranches</h3>
<p>Il est possible de sélectionner <strong>une partie</strong> d&#39;une séquence de la manière suivante&nbsp;:</p>
<pre><code class="language-python">j = nombres[2:5]
</code></pre>
<p>Dans le code ci-dessus, <code>j</code> contiendra <code>[3, 5, 6]</code>. La tranche <code>[m,n]</code> est une <strong>nouvelle liste</strong> contenant les éléments de l&#39;indice <code>m</code> inclus à l&#39;indice <code>n</code> <strong>exclu</strong>.</p>
<p>Si on omet la première des deux bornes (<code>nombres[:5]</code>), la tranche commencera au début de la liste originale. Si c&#39;est la fin qui est omise (<code>nombres[2:]</code>), la tranche ira jusqu&#39;à la fin de la liste originale.</p>
<p>On peut également <strong>remplacer</strong> une tranche de liste par une autre&nbsp;:</p>
<pre><code class="language-python">nombres[2:5] = [&#39;toto&#39;, &#39;tata&#39;, &#39;tutu&#39;, &#39;titi&#39;]
</code></pre>
<p>Après l&#39;instruction ci-dessus, la liste <code>nombres</code> contiendra <code>[1, 2, &#39;toto&#39;, &#39;tata&#39;, &#39;tutu&#39;, &#39;titi&#39;, &#39;sept&#39;]</code>.</p>
<p>Il est également possible d&#39;ajouter des éléments de cette manière&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 5, 6]

L[2:2] = [3, 4]

# L vaut maintenant [1, 2, 3, 4, 5, 6]
</code></pre>
<p>Donc, pour ajouter un élément en début de liste, on procèderait comme suit&nbsp;:</p>
<pre><code class="language-python">L = [2, 3, 4]

L[:0] = [1]

# L vaut maintenant [1, 2, 3, 4]
</code></pre>
<p>Et, pour ajouter un élément en fin de liste, on procèderait comme suit&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 3, 4]

L[len(L):] = [5]

# L vaut maintenant [1, 2, 3, 4, 5]
</code></pre>
<h3>Méthodes</h3>
<p>Nous avons vu plus haut comment ajouter des éléments dans une liste en utilisant des assignations à des tranches. Bien que cette façon de modifier une liste soit très puissante, elle n&#39;est <strong>pas</strong> très <strong>pratique</strong> à utiliser pour des opérations simples et courantes comme l&#39;ajout en fin de liste.</p>
<p>En réalité il existe tout un tas de <strong>fonctionnalités</strong> associées au type <code>list</code>. L&#39;une d&#39;entre elle permet d&#39;ajouter un élément en fin de liste et s&#39;appelle <code>append</code>. Voici comment on l&#39;utilise&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 3, 4]
L.append(5)
# L vaut maintenant [1, 2, 3, 4, 5]
</code></pre>
<p>Vous pouvez voir que pour utiliser la fonctionnalité <code>append</code> des listes, on doit appeler la fonction <code>append()</code> attachée <strong>(avec un <code>.</code>)</strong> à la valeur de type <code>list</code> sur laquelle on souhaite appliquer la fonctionnalité.</p>
<p>On appelle ce genre de fonctionnalités des <strong>méthodes</strong>.</p>
<p>Nous n&#39;allons pas voir ici toutes les méthodes du type <code>list</code> mais nous allons quand même mentionner les méthodes <code>insert()</code> et <code>pop()</code>&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 4, 5]
L.insert(2, 3) # insère l&#39;élément 3 à l&#39;indice 2
# L vaut maintenant [1, 2, 3, 4, 5]

v = L.pop(2) # enlève et renvoie l&#39;élément d&#39;indice 2
# L vaut de nouveau [1, 2, 4, 5] et v contient 3
</code></pre>
<h3>Opérations</h3>
<h4>Concaténation</h4>
<p>Il est possible de créer une <strong>nouvelle séquence</strong> correspondant à la concaténation de deux séquences, c&#39;est-à-dire, de la mise bout à bout de ces deux séquences. Pour cela, on utilise l&#39;opération <code>+</code>.</p>
<pre><code class="language-python">L1 = [1, 2, 3]
L2 = [4, 5, 6]
L3 = L1 + L2   # L3 sera égal à [1, 2, 3, 4, 5, 6]

s1 = &#39;hello &#39;
s2 = &#39;world&#39;
s3 = s1 + s2   # s3 sera égal à &#39;hello world&#39;
</code></pre>
<h4>Répétition</h4>
<p>On peut également créer une <strong>nouvelle séquence</strong> correspondant à la répétition d&#39;une séquence en utilisant l&#39;opérateur <code>*</code>.</p>
<pre><code class="language-python">L1 = [1, 2, 3]
L2 = L1 ∗ 2    # L2 sera égal à [1, 2, 3, 1, 2, 3]

s1 = &#39;hello &#39;
s2 = s1 ∗ 3    # s2 sera égal à &#39;hello hello hello&#39;
</code></pre>
<h4>L&#39;opérateur <code>in</code></h4>
<p>L&#39;opérateur <code>in</code> renvoie <code>True</code> si l&#39;élément à sa gauche est dans la séquence à sa droite.</p>
<p>Pour vérifier si une valeur se trouve dans une liste, on peut utiliser l&#39;instruction <code>in</code> dans
un <code>if</code>&nbsp;:</p>
<pre><code class="language-python">L = [1, 2, 5, 6]
if 2 in L:
    print(&quot;2 est dans la liste&quot;)
else:
    print(&quot;2 n&#39;est pas dans la liste&quot;)
</code></pre>
<h3>L&#39;instruction <code>for … in …</code></h3>
<p>Pour effectuer un traitement sur <strong>tous les éléments</strong> d&#39;une séquence, il est bien sûr possible d&#39;utiliser une boucle <code>while</code>. Cependant, le Python prévoit une boucle <code class="nowrap">for … in …</code> permettant de le faire de façon plus pratique.</p>
<div class="row">
<div class="span5 middle">

<pre><code class="language-python">for variable in séquence:
    bloc_d_instruction
</code></pre>
</div>
<div class="span7">
<figure id='for_in' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>for … in …</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#for_in > div', 350, 400)
    const start = draw.start().move(1, 2)
    const init = draw.round('On démarre du premier élément de la liste').belowOf(start)
    const back = draw.dummy().belowOf(init)
    const cond = draw.round('l\'élément existe-t-il ?').belowOf(back)
    const if1 = draw.diamond().belowOf(cond)
    const oui = draw.node('oui').belowOf(if1)
    const non = draw.node('non').rightOf(if1)
    const dummy = draw.dummy().leftOf(if1)
    const assign = draw.round('<code>variable</code> prend la valeur de l\'élément').belowOf(oui)
    const bloc = draw.round('exécution du <code>bloc_d_instructions</code>').belowOf(assign)
    const inc = draw.round('On passe à l\'élément suivant').belowOf(bloc)
    const end = draw.end().belowOf(inc)
    draw.polyline([start, '-->', init, '--', back, '-->', cond, '-->', if1, '--', oui, '-->', assign, '-->', bloc, '-->', inc, '-|', dummy, '|->', back])
    draw.polyline([if1, '--', non, '|->' , end])
    draw.done()
</script>
</div>
</div>

<p>Dans une boucle <code>for … in …</code>, la variable prend <strong>successivement</strong> la valeur de chaque élément de la liste.</p>
<p>Le code suivant&nbsp;:</p>
<pre><code class="language-python">L = [&#39;truc&#39;, &#39;machin&#39;, &#39;bidule&#39;]

for a in L:
    print(a)
</code></pre>
<p>affichera&nbsp;:</p>
<div class="terminal">
    truc
    machin
    bidule
</div>

<p>Dans le code ci-dessus, la variable <code>a</code> vaut <code>&#39;truc&#39;</code> au premier tour de boucle, <code>&#39;machin&#39;</code> au deuxième tour de boucle et <code>&#39;bidule&#39;</code> au troisième tour de boucle.</p>
<h3>Les copies</h3>
<p>Nous allons voir voir ici que l&#39;on peut facilement avoir des surprises lorsqu&#39;on essaye de faire une copie d&#39;une liste.</p>
<p>Dans le code qui va suivre, nous allons essayer de créer une copie d&#39;une liste pour pouvoir modifier la copie tout en gardant l&#39;original inchangé&nbsp;:</p>
<pre><code class="language-python">original = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]   # liste originale
copie = original                     # copie de l&#39;originale

copie[1] = &#39;love&#39;                     # modification de la copie

print(original)                      # affichage de l&#39;originale
print(copie)                          # affichage de la copie
</code></pre>
<p>Ce qui affiche&nbsp;:</p>
<div class="terminal">
['I', 'love', 'Python']
['I', 'love', 'Python']
</div>

<p>On constate donc que les deux listes ont été modifiées et que l&#39;originale a été <strong>perdue</strong>. En effet, le fait d&#39;écrire <code>copie = original</code>, ne crée <strong>pas</strong> de nouvelle liste.</p>
<p>En Python, comme dans beaucoup d&#39;autres langages de programmation, dès qu&#39;elle contient un type plus complexe qu&#39;un simple nombre, une variable ne contient pas directement sa valeur mais seulement une <strong>référence</strong> à celle-ci. Lorsqu&#39;on écrit <code>copie = original</code> on ne fait une copie que de la référence. On se retrouve donc avec deux variables qui manipulent la même liste.</p>
<figure id='references' data-ref='figure'>
    <img src="./references.svg" class="half">
    <figcaption>Deux références pour la même liste</figcaption>
</figure>


<p>Ce système de référence existe car la copie de types complexes <strong>prend du temps</strong> et n&#39;est souvent pas souhaitable.</p>
<p>Pour créer une vraie copie de la liste, on peut utiliser un <em>slicing</em>&nbsp;:</p>
<pre><code class="language-python">original = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]   # liste originale
copie = original[:]                  # copie de l&#39;originale

copie[1] = &#39;love&#39;                     # modification de la copie

print(original)                      # affichage de l&#39;originale
print(copie)                          # affichage de la copie
</code></pre>
<p>Ce qui affiche&nbsp;:</p>
<div class="terminal">
['I', 'like', 'Python']
['I', 'love', 'Python']
</div>


<p>Un <em>slicing</em> crée toujours une <strong>nouvelle liste</strong>. On obtient donc bien une vrai copie de l&#39;originale. Il existe d&#39;autres opérations que l&#39;on peut exploiter pour obtenir le même résultat&nbsp;:</p>
<pre><code class="language-python">copie = original * 1
copie = original + []
</code></pre>
<p>On peut aussi utiliser la fonction <code>list()</code> qui <strong>crée une liste</strong> à partir de ce qu&#39;on lui passe en paramètre&nbsp;:</p>
<pre><code class="language-python">copie = list(original)
</code></pre>
<h2>Les chaînes de caractères</h2>
<p>Comme nous l&#39;avons déjà dit plus haut, les chaines de caractères et les listes partagent beaucoup de fonctionnalités&nbsp;:</p>
<pre><code class="language-python">s = &#39;Python&#39;

print(s[1])      # affiche &#39;y&#39;
print(len(s))    # affiche 6
print(s[1:3])    # affiche &#39;yt&#39;
print(s * 2)     # affiche &#39;PythonPython&#39;
print(&#39;I love &#39; + s) # affiche &#39;I love Python&#39;

for l in s:
    print(l)     # affiche :
                 # P
                 # y
                 # t
                 # h
                 # o
                 # n
</code></pre>
<p>Il y a bien sûr quelques différences.</p>
<h3>Opérateur <code>in</code></h3>
<p>L&#39;opérateur <code>in</code> fonctionne aussi avec les chaines de caractères&nbsp;:</p>
<pre><code class="language-python">if &quot;l&quot; in &quot;salut&quot;:
    print(&quot;&#39;l&#39; est une lettre de &#39;salut&#39;&quot;)
</code></pre>
<p>Mais il fonctionne aussi quand l&#39;opérande de droite est une <strong>sous-chaîne</strong>&nbsp;:</p>
<pre><code class="language-python">if &quot;al&quot; in &quot;salut&quot;:
    print(&quot;&#39;al&#39; est une sous-chaine de &#39;salut&#39;&quot;)
</code></pre>
<h3>Immuable</h3>
<p>Il y a une grande différence entre les listes et les chaines de caractères : les listes sont des séquences modifiables alors que les chaines de caractères sont des séquences <strong>non-modifiables</strong> ou <strong>immuables</strong>.</p>
<p>En gros, cela veut dire qu&#39;on peut modifier une liste&nbsp;:</p>
<pre><code class="language-python">L = [&#39;I&#39;, &#39;like&#39;, &#39;Python&#39;]
L[2] = &#39;love&#39;     # ceci fonctionne
</code></pre>
<p>Mais qu&#39;on ne peut <strong>pas</strong> modifier une chaine de caractères. Le code suivant ne fonctionne donc pas&nbsp;:</p>
<pre><code class="language-python">s = &quot;Le Python, c&#39;est bon !&quot;
s[17] = &quot;c&quot;       # ceci ne fonctionne pas !
</code></pre>
<p>La suppression et l&#39;insertion de caractères est également interdite pour les chaines de caractères.</p>
<p>Voyons maintenant le code suivant&nbsp;:</p>
<pre><code class="language-python">s = &quot;Le Python, c&#39;est bon !&quot;
s = s[:17] + &quot;cool&quot; + s[20:] # ceci fonctionne
</code></pre>
<p>Ce code affichera bien <code>Le Python, c&#39;est cool !</code>. Il semble donc que la chaine de caractères <code>s</code> ait bien été modifiée puisque sa valeur était <code>&quot;Le Python, c&#39;est bon !&quot;</code> au départ. Mais en réalité, la chaine de départ n&#39;a pas changé. C&#39;est la <strong>référence</strong> dans la variable <code>s</code> qui a été <strong>remplacée</strong>. La somme <code>s[:17] + &quot;cool&quot; + s[20:]</code> crée <strong>une nouvelle chaine de caractères</strong>, indépendante de la chaine <code>&quot;Le Python, c&#39;est bon !&quot;</code> d&#39;origine. La variable <code>s</code> contient ensuite une référence vers cette nouvelle chaine à cause de l&#39;assignation (<code>s =</code>). Du coup, plus aucune variable ne référence la chaine d&#39;origine ce qui provoquera son <strong>effacement</strong> de la mémoire.</p>
<h2>Les tuples</h2>
<p>Un tuple, comme une liste, est une suite de valeurs pouvant être de différents types. La grosse différence entre les listes et les tuples, c&#39;est que les tuples sont <strong>immuables</strong>. Les éléments d&#39;un tuple ne peuvent pas être réassignés et on ne peut pas en ajouter ou en enlever.</p>
<p>Pour définir un tuple, on peut utiliser des parenthèses mais elles sont <strong>optionnelles</strong>&nbsp;:</p>
<pre><code class="language-python"># Tuple vide
a = ()

# Tuples contenant un seul élément
b = 1,
c = (1,)

# Tuples contenant trois éléments
d = 1, 2, 3
e = (1, 2, 3)
</code></pre>
<p>On remarque que pour le tuple à un seul élément, on est obligé de mettre <strong>une virgule</strong> à la fin. Sans cette virgule, on ne saurait pas faire la différence entre une valeur et la même valeur seule dans un tuple.</p>
<h3>Déballage</h3>
<p>Tout comme il est possible d&#39;<strong>emballer</strong> plusieurs valeurs dans un tuple&nbsp;:</p>
<pre><code class="language-python">t = 1, 2, 3
</code></pre>
<p>Il est également possible de <strong>déballer</strong> un tuple dans plusieurs variables&nbsp;:</p>
<pre><code class="language-python">a, b, c = t
</code></pre>
<p>Il faut, bien entendu, qu&#39;il y ait <strong>autant de valeurs que de variables</strong>.</p>
<p>Lorsqu&#39;on combine un emballage avec un déballage, on obtient <strong>une assignation multiple</strong>&nbsp;:</p>
<pre><code class="language-python">a, b, c = 1, 2, 3
</code></pre>
<h2>Les intervalles</h2>
<p>Un intervalle est une séquence numérique <strong>régulière</strong>. On les crée avec la fonction <code>range()</code>&nbsp;:</p>
<pre><code class="language-python">range(5)         # séquence 0, 1, 2, 3, 4
range(1, 5)      # séquence 1, 2, 3, 4
range(1, 8, 2)   # séquence 1, 3, 5, 7
range(5, 0, -1)  # séquence 5, 4, 3, 2, 1 
</code></pre>
<p>Lorsqu&#39;on ne passe qu&#39;un paramètre <code>n</code> à la fonction <code>range()</code>, elle retourne un intervalle démarrant à <code>0</code>, progressant par pas de <code>1</code> et s&#39;arrêtant un pas avant d&#39;atteindre <code>n</code>.</p>
<p>Si on indique deux paramètres, l&#39;intervalle commencera à la valeur du premier et finira un pas avant le deuxième. Et si on en indique trois, le troisième sera utilisé comme pas.</p>
<p>Si on tente d&#39;afficher un intervalle avec la fonction <code>print()</code>, le résultat n&#39;est pas très intéressant&nbsp;:</p>
<pre><code class="language-python">print(range(5))  # affiche range(0, 5)
</code></pre>
<p>Si l&#39;on souhaite voir toutes les valeurs qui sont dans l&#39;intervalle, il est possible de le <strong>convertir en liste</strong> pour l&#39;affichage&nbsp;:</p>
<pre><code class="language-python">print(list(range(5)))   # affiche [0, 1, 2, 3, 4]
</code></pre>
<p>Les intervalles sont des séquences <strong>immuables</strong>. Ils supportent l&#39;accès aux éléments et les tranches&nbsp;:</p>
<pre><code class="language-python">r = range(1, 8, 2)

print(r[2])    # affiche 5
print(r[1:3])  # affiche range(3, 7, 2)
</code></pre>
<p>Comme les intervalles sont immuables, on pourrait penser qu&#39;ils sont équivalents aux tuples. Mais ils sont très différents en réalité. Si on crée un tuple <code>(1, 2, 3, 4, 5)</code>, les 5 entiers sont <strong>sauvés en mémoire</strong>. Si on crée un tuple similaire qui va jusque <code>100</code>, ce sera 100 entiers sauvés en mémoire. Les intervalles ne sauvent que <strong>3 valeurs en mémoire</strong>: la valeur de début, la valeur de fin et le pas. Les éléments de l&#39;intervalle sont <strong>calculés au moment où on les demande</strong>.</p>
<p>Les intervalles sont souvent utilisés dans les boucles <code>for</code>&nbsp;:</p>
<pre><code class="language-python">for i in range(5):
  print(i)
</code></pre>
<p>On les utilise couramment pour parcourir les indices d&#39;une liste&nbsp;:</p>
<pre><code class="language-python">names = [&#39;Quentin&#39;, &#39;André&#39;, &#39;Clémence&#39;]
for i in range(len(names)):
    print(&quot;l&#39;élément d&#39;indice&quot;, i, &quot;est&quot;, names[i])
</code></pre>
<div class="terminal">
l'élément d'indice 0 est Quentin
l'élément d'indice 1 est André
l'élément d'indice 2 est Clémence
</div>

<h2>Les énumérations</h2>
<p>Il existe en Python une fonction appelée <code>enumerate()</code>. Cette fonction prend une séquence en paramètre et renvoie une séquence de <strong>tuples</strong>. Chaque tuple correspond à un des éléments de la liste de départ et contient un numéro d&#39;ordre <em>(commençant à <code>0</code>)</em> et l&#39;élément en question.</p>
<p>Tout comme les intervalles, la séquence renvoyée n&#39;est pas sauvée en mémoire mais ses éléments sont <strong>calculés à la demande</strong>&nbsp;:</p>
<pre><code class="language-python">L = [&#39;un&#39;, &#39;deux&#39;, &#39;trois&#39;]

print(enumerate(L))        # affiche &lt;enumerate at 0x10035e570&gt;
print(list(enumerate(L)))  # affiche [(0, &#39;un&#39;), (1, &#39;deux&#39;), (2, &#39;trois&#39;)]
</code></pre>
<p>On constate qu&#39;une énumération contient à la fois les <strong>indices</strong> et les <strong>valeurs</strong> de la liste de départ. En combinant cette fonction avec l&#39;<strong>assignation multiple</strong>, que l&#39;on a vue plus haut, il est facile de parcourir à la fois les indices et les valeurs d&#39;une séquence avec une boucle <code>for</code>&nbsp;:</p>
<pre><code class="language-python">for i, value in enumerate(L):
    print(&quot;l&#39;élément d&#39;indice&quot;, i, &quot;est&quot;, value)
</code></pre>
<div class="terminal">
l'élément d'indice 0 est un
l'élément d'indice 1 est deux
l'élément d'indice 2 est trois
</div>

<p>À chaque tour de boucle, un des tuples de l&#39;énumération est <strong>déballé</strong> dans les deux variables <code>i</code> et <code>value</code> du <code>for</code>.</p>
<p>Bien que les énumérations soient très utiles pour parcourir des séquences, elles ne sont pas des séquences elles-mêmes. En effet, l&#39;accès à un élément (<code>[]</code>) ne fonctionne pas.</p>

</body>
</html>
