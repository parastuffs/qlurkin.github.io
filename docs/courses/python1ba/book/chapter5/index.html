<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 5 - Les fonctions</title>
    <script src="/document.js" defer></script>
    
</head>
<body>
    <h1>Chapitre 5 <small>Les fonctions</small></h1>
    
    <p>Une fonction est un <strong>sous-programme</strong> à qui on fournit des valeurs <em>(les valeurs d&#39;entrée)</em> et qui peut produire un résultat <em>(une valeur de sortie)</em>.</p>
<p>Nous avons déjà utilisé la fonction <code>print().</code> Cette fonction est une fonction prédéfinie du Python. Elle prend un paramètre <em>(une valeur d&#39;entrée, la valeur à afficher)</em> et ne renvoie <strong>pas de résultat</strong>. Par contre, elle a bien une utilité puisqu&#39;elle affiche la valeur de son paramètre à l&#39;écran.</p>
<p>Le Python contient déjà beaucoup de fonctions prédéfinies mais l&#39;objectif de ce chapitre est de voir comment <strong>ajouter</strong> de nouvelles fonctions au langage. L&#39;intérêt de créer ses propres fonctions est double. Premièrement, lorsqu&#39;un programme devient un peu long, il est possible et même fortement recommandé de le <strong>diviser</strong> en plusieurs fonctions pour que la complexité de chaque partie <em>(chaque fonction)</em> reste maitrisable. Deuxièmement, il arrive régulièrement qu&#39;un programme utilise plusieurs fois la même séquence d&#39;instructions. Là encore, les fonctions permettent de <strong>ne pas devoir écrire plusieurs fois la même chose</strong>.</p>
<p>Pour définir une fonction, on utilise l&#39;instruction composée <code>def</code> :</p>
<pre><code class="language-python">def nom_de_la_fonction:
  bloc_d_instructions
</code></pre>
<p>Le code ci-dessus constitue la définition de la fonction, c&#39;est-à-dire, l&#39;ajout de la fonction au langage. Définir une fonction ne sert à rien si on n&#39;utilise pas la fonction quelque part. Pour utiliser la fonction (on dit souvent « appeler » la fonction), on utilise son nom suivit des parenthèses contenant les éventuels paramètres comme on l&#39;a fait à chaque fois qu&#39;on a utilisé la fonction <code>print()</code>. Il est important de bien différencier la définition de la fonction et le ou les appels à la fonction.</p>
<h2>Fonctions sans paramètre et sans valeur de retour</h2>
<p>La fonction dont la définition est la suivante&nbsp;:</p>
<pre><code class="language-python">def hello():
  print(&#39;Hello World!&#39;)
</code></pre>
<p>affiche <code>Hello World!</code>.</p>
<p>Elle ne prend aucun paramètre <em>(les parenthèses sont vides)</em> et affichera donc exactement la même chose à chaque fois qu&#39;elle sera utilisée.</p>
<p>Elle ne renvoie aucune valeur. Cela veut dire que ça n&#39;a <strong>aucun intérêt</strong> d&#39;écrire <code>a = hello()</code> (quelle valeur pourrait bien se retrouver dans a?). Cela n&#39;empêche pas la fonction d&#39;être utile puisqu&#39;elle affiche un message.</p>
<h2>Fonctions avec un paramètre et sans valeur de retour</h2>
<p>L&#39;utilité de la fonction <code>hello()</code> est quand même très limitée. Elle ne sait faire qu&#39;une chose très précise : afficher <code>Hello World!</code>.</p>
<p>On peut facilement la rendre plus utile en utilisant un <strong>paramètre</strong>. Celui-ci sera un nom de personne à saluer.</p>
<p>Voici la définition de la fonction modifiée :</p>
<pre><code class="language-python">def hello(name):
  print(&#39;Hello &#39; + name + &#39;!&#39;)
</code></pre>
<p>et voici quelques appels avec les résultats correspondants :</p>
<pre><code class="language-python">hello(&#39;LUR&#39;)   # affichera Hello LUR!
hello(&#39;1BA&#39;)   # affichera Hello 1BA!
hello(&#39;ECAM&#39;)  # affichera Hello ECAM!
</code></pre>
<h2>Fonctions avec plusieurs paramètres et sans valeur de retour</h2>
<p>Pouvoir passer un paramètre à une fonction est très utile mais il serait intéressant de pouvoir en passer <strong>plusieurs</strong>. Nous pourrions passer l&#39;heure de la journée pour adapter le message de salutation&nbsp;:</p>
<pre><code class="language-python">def hello(name, hour):
  msg = &#39;Bonjour&#39;
  if hour &gt; 12:
    msg = &#39;Bon après-midi&#39;
  if hour &gt; 16:
    msg = &#39;Bonsoir&#39;
  if hour &gt; 22:
    msg = &#39;Bonne nuit&#39;

  print(msg + &#39; &#39; + name + &#39;!&#39;)
</code></pre>
<p>Il est donc maintenant possible d&#39;appeler la fonction comme suit&nbsp;:</p>
<pre><code class="language-python">hello(&#39;Quentin&#39;, 17)   # affichera Bonsoir Quentin!
</code></pre>
<p>Par contre, il n&#39;est plus possible de l&#39;appeler en ne mentionnant qu&#39;un seul paramètre comme avant. Il serait intéressant de pouvoir appeler la fonction des deux manières : soit on ne mentionne qu&#39;un paramètre et on utilise <code>Bonjour</code>, soit on mentionne deux paramètres et le message est adapté à l&#39;heure. Et bien c&#39;est possible et relativement simple à obtenir. Il suffit pour cela de donner des <strong>valeurs par défaut</strong> aux paramètres :</p>
<pre><code class="language-python">def hello(name, hour=10):
  msg = &#39;Bonjour&#39;
  if hour &gt; 12:
    msg = &#39;Bon après-midi&#39;
  if hour &gt; 16:
    msg = &#39;Bonsoir&#39;
  if hour &gt; 22:
    msg = &#39;Bonne nuit&#39;

  print(msg + &#39; &#39; + name + &#39;!&#39;)
</code></pre>
<p>Avec cette définition, il est possible d&#39;appeler la fonction des deux façons&nbsp;:</p>
<pre><code class="language-python">hello(&#39;Quentin&#39;, 17)        # affichera Bonsoir Quentin!
hello(&#39;Lurkin&#39;)             # affichera Bonjour Lurkin!
hello(hour=15, name=&#39;ECAM&#39;) # affichera Bon après-midi ECAM!
</code></pre>
<p>Comme on le voit dans le troisième appel, il est possible de <strong>nommer explicitement</strong> les paramètres auxquels on veut donner une valeur et donc de les mentionner dans un autre ordre si on le souhaite.</p>
<h2>Fonctions avec valeur de retour</h2>
<p>Les fonctions que nous avons écrites jusqu&#39;à présent ne renvoient pas de valeur. C&#39;est-à-dire que ça n&#39;a aucun sens d&#39;écrire <code>a = hello(...)</code> (vous pouvez essayer de faire <code>print(a)</code> après avoir fait <code>a = hello(&#39;LUR&#39;)</code>). Il est cependant possible pour une fonction de <strong>renvoyer</strong> une valeur en utilisant le mot-clé <code>return</code>. Voici un exemple avec la fonction valeur absolue&nbsp;:</p>
<pre><code class="language-python">def abs(x):
  if x &lt; 0:
    res = −x
  else :
    res = x
  return res
</code></pre>
<p>Cette fonction renvoie la valeur absolue du paramètre. On peut donc écrire&nbsp;:</p>
<pre><code class="language-python">a = abs(-2)
print(a)    # affichera 2
</code></pre>
<p>Ici, la valeur absolue de -2 est mise dans <code>a</code> puis on affiche la valeur de <code>a</code>.</p>
<p>Il est important ici de constater qu&#39;une fonction qui renvoie une valeur peut être utilisée partout où une valeur peut être utilisée. En particulier, elle peut être utilisée à l&#39;intérieur d&#39;une expression ou comme paramètre d&#39;une autre fonction :</p>
<pre><code class="language-python">print(3 ∗ abs(−2) − 1)   # affichera 5
</code></pre>
<h2>Utilité des fonctions</h2>
<h3>Éviter les répétitions</h3>
<p>La première utilité des fonctions est bien évidemment d&#39;<strong>éviter de devoir écrire plusieurs fois une même portion de code</strong>. On conçoit aisément que si, à chaque fois qu&#39;on veut calculer une valeur absolue, il faut réécrire le code de la fonction <code>abs()</code>, cela va vite devenir lourd.</p>
<p>Outre le fait de gagner du temps et de la place (moins de lignes de code), le fait de ne pas devoir répéter du code a plusieurs avantages :</p>
<ul>
<li>lorsqu&#39;on doit écrire plusieurs fois la même chose, on a toutes les chances de se tromper à un moment ou à un autre (même en faisant des « copier/coller »).</li>
<li>il est particulièrement pénible, lorsqu&#39;une modification doit être apportée, de <strong>devoir répéter cette modification</strong> à plusieurs endroits du programme. De plus, on risque là aussi de se tromper ou d&#39;oublier une des répétitions.</li>
</ul>
<h3>Structurer le programme</h3>
<p>Les fonctions peuvent, cependant, être utiles même si on ne les appelle qu&#39;une seule fois. Observons le programme suivant&nbsp;:</p>
<pre><code class="language-python">n=1
nb = 10
while nb &gt; 0:
  divisors = 0
  d=1
  while d &lt;= n:
    if n % d == 0:
      divisors += 1
    d += 1
  if divisors == 2:
    print(n)
    nb -= 1
  n += 1 
</code></pre>
<p>Ce programme ne comporte aucune fonction. Il sert à afficher les 10 premiers nombres premiers. Si on examine le code, on se rend compte qu&#39;il contient deux boucles imbriquées, ce qui fait de lui un programme plutôt <strong>complexe</strong>. Lorsqu&#39;on écrit un programme de ce genre, il est très facile de faire une erreur quelque part et il est, en général, assez pénible de la retrouver.</p>
<p>Examinons maintenant le même programme <strong>découpé en fonctions</strong>&nbsp;:</p>
<pre><code class="language-python">def isDivisor(d, n):
  return n % d == 0

# n strictement supérieur à 1 (1 n&#39;est jamais premier)
def isPrime(n):
  d=2
  while not isDivisor(d, n):
    d += 1
  return d == n

def printPrimes(nb):
  n=2
  while nb &gt; 0:
    if isPrime(n):
      print(n)
      nb -= 1
    n += 1

nb_prime = 10
printPrimes(nb_prime)
</code></pre>
<p>Chaque fonction n&#39;est appelée qu&#39;une seule fois. L&#39;intérêt n&#39;est donc pas d&#39;éviter des répétitions de code. Même si le programme global semble plus long, chaque fonction individuelle est <strong>courte et simple</strong>, ce qui en facilite l&#39;écriture et la compréhension. De plus, chaque fonction peut être testée individuellement, ce qui simplifiera la recherche d&#39;erreur. Ceci nous amène au plus important conseil de ce cours :</p>
<p class="big">Il vaut mieux beaucoup de petites fonctions que peu de grandes fonctions !</p>

<h2>Variables locales et globales</h2>
<p>Dès qu&#39;on commence à utiliser des fonctions, la notion de variables <strong>locales</strong> et <strong>globales</strong> entre en jeu.</p>
<p>Une variable globale est une variable définie pour l&#39;ensemble du programme tandis qu&#39;une variable locale est définie pour une fonction particulière. Dans notre programme d&#39;affichage de nombres premiers dans sa version « découpée en fonctions », il y a une variable globale : <code>nb_prime</code>. On reconnait qu&#39;elle est globale car elle est définie <strong>en dehors de toute fonction</strong>. Elle est définie pour l&#39;ensemble du programme et est donc accessible même à l&#39;intérieur des fonctions.</p>
<p>Les variables locales, quant à elles, sont définies <strong>à l&#39;intérieur d&#39;une fonction</strong> : par exemple, la variable <code>d</code> de la fonction <code>isPrime()</code>. Ce type de variable n&#39;est accessible <strong>qu&#39;à l&#39;intérieur</strong> de la fonction où elle est définie. L&#39;avantage de ce cloisonnement de variables est que l&#39;on peut <strong>réutiliser</strong> le même nom de variable dans plusieurs fonctions : par exemple on peut voir qu&#39;il y a une variable locale nommée <code>d</code> dans la fonction <code>isDivisor()</code>. La variable <code>d</code> de la fonction <code>isPrime()</code> et la variable <code>d</code> de la fonction <code>isDivisor()</code> sont deux variables complètement indépendantes. Si les variables locales n&#39;étaient pas cloisonnées à l&#39;intérieur de leurs fonctions, il faudrait, à chaque fois qu&#39;on veut utiliser une nouvelle variable, trouver un nom qui n&#39;a pas encore été utilisé. Cela peut très vite devenir un problème lorsque le programme devient un peu long. Le cloisonnement nous permet donc d&#39;écrire les fonctions sans se soucier de ce qui est fait dans les autres.</p>
<pre><code class="language-python">def fct():
  a = 20

fct()
print(a)
</code></pre>
<p>Le programme ci-dessus vous affichera&nbsp;:</p>
<div class="terminal">
NameError: name 'a' is not defined
</div>

<p>Par contre une variable globale est accessible dans les fonctions&nbsp;:</p>
<pre><code class="language-python">a = 20

def fct():
  print(a)

fct()
</code></pre>
<p>Ce programme affichera bien 20.</p>
<p>Que se passe-t-il lorsqu&#39;une variable locale a le même nom qu&#39;une variable globale ?</p>
<pre><code class="language-python">a=20

def fct():
  a = 30
  print(&#39;dans fct:&#39;, a)

fct()
print(&#39;hors fct:&#39;, a)
</code></pre>
<p>Le programme ci-dessus affichera&nbsp;:</p>
<div class="terminal">
30
20
</div>

<p>Au début, nous définissons une variable globale <code>a</code>. Ensuite, dans la fonction, nous donnons une nouvelle valeur à <code>a</code> mais, en faisant cela, nous ne modifions pas la variable globale. En effet, c&#39;est une variable locale nommée <code>a</code> qui est créée et qui prend la valeur <code>30</code>. Le <code>print()</code> de la fonction affiche donc la valeur de la variable locale. Cette variable locale masque la variable globale portant le même nom. Pour finir, le deuxième <code>print()</code> affiche la valeur de la variable globale qui est bien restée à <code>20</code>.</p>
<p>On remarque donc qu&#39;il n&#39;est pas possible de modifier une variable globale de l&#39;intérieur d&#39;une fonction. En fait, il s&#39;agit ici du comportement par défaut des variables globales. Il est possible de modifier ce comportement en utilisant l&#39;instruction <code>global</code>&nbsp;:</p>
<pre><code class="language-python">a = 20

def fct():
  global a
  a = 30

fct()
print(a)
</code></pre>
<p>Le programme ci-dessus affichera <code>30</code>. Le fait d&#39;avoir déclaré <code>a</code> comme globale dans la fonction permet d&#39;écrire dans la variable globale sans créer de variable locale.</p>
<p class="big">Il est important de préciser ici que l'usage de l'instruction <code>global</code> est considéré comme une mauvaise pratique et qu'il faut absolument éviter de l'utiliser.</p>

<p><strong>Petite remarque supplémentaire</strong> : si vous définissez une variable locale dans une fonction, elle est définie dans toute la fonction, <strong>même avant sa définition</strong>. Le code suivant donne donc une erreur&nbsp;</p>
<pre><code class="language-python">a=20

def fct():
  print(&#39;avant la définition de a:&#39;, a)
  a = 30

fct()
print(&#39;hors fct:&#39;, a)
</code></pre>
<div class="terminal">
UnboundLocalError: cannot access local variable 'a' where it is
 not associated with a value
</div>

<p>Comme une variable <code>a</code> est définie dans la fonction, le <code>print()</code> à la première ligne de la fonction <code>fct()</code> tente d&#39;en utiliser la valeur. Mais à ce moment-là de la fonction, la variable <code>a</code> n&#39;a pas encore reçu de valeur. On obtient donc le message d&#39;erreur <code>UnboundLocalError</code>.</p>
<h2>Les fonctions récursives</h2>
<p>En programmation, rien n&#39;interdit à une fonction de <strong>s&#39;appeler elle-même</strong>. Les fonctions qui s&#39;appellent elles-mêmes sont appelées des <strong>fonctions récursives</strong>.</p>
<p>Voici un exemple avec la fonction factorielle&nbsp;:</p>
<pre><code class="language-python">def fact(n):
  if n &gt; 1:
    return n ∗ fact(n−1)
  else:
    return 1
</code></pre>
<p>On voit ici qu&#39;il y a un appel récursif dans la fonction. Il est bien sûr extrêmement important qu&#39;une fonction récursive ne se rappelle pas <strong>éternellement</strong>. Pour cela, une fonction récursive comporte toujours un <strong>cas de base</strong>, c&#39;est-à-dire, un cas où la valeur de fonction peut être déterminée sans appel récursif. Dans le cas de la fonction factorielle, il s&#39;agit du cas <code>n &lt;= 1</code>. Il faut également que la suite d&#39;appels récursifs finisse toujours par attendre le cas de base.</p>
<h2>Les modules</h2>
<p>Lorsqu&#39;on crée des fonctions qui peuvent être utiles dans plusieurs programmes ou que le fichier du programme devient très long, il est intéressant de créer des modules.</p>
<p>Ces modules sont semblables au module <code>math</code> que nous avons déjà utilisé auparavant. Ils contiennent des définitions de fonctions et peuvent être importés (<code>from ... import ...</code>) dans un programme qui pourra alors utiliser ces fonctions.</p>
<h3>Le module <code>turtle</code></h3>
<p>Avant de créer nos propres modules, nous allons examiner un des modules <strong>prédéfinis</strong> du Python qui nous servira par la suite.</p>
<p>Le module <code>turtle</code> sert à réaliser des dessins en faisant se déplacer une « tortue ». Voici un exemple :</p>
<pre><code class="language-python">from turtle import *

for i in range(4):
  forward(100)
  left(90)

done()
</code></pre>
<p>La première ligne sert bien sûr à importer toutes les fonctions du module <code>turtle</code>.</p>
<p>Vient ensuite une boucle qui effectue 4 tours. A chacun d&#39;entre eux, la « tortue » avancera de 100 pixels et tournera de 90° vers la gauche. Durant tous ces déplacements, la « tortue » trace une ligne derrière elle, ce qui aboutit au dessin suivant :</p>
<figure><img src="./turtle.png" alt=""></figure>

<p>Dans l&#39;image ci-dessus, la flèche représente la « tortue ».</p>
<p>Voici quelques fonctions utiles pour manipuler la « tortue » :</p>
<table>
  <thead>
    <tr>
      <th>Fonctions</th>
      <th>Descriptions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>forward(distance)</code></td>
      <td>Avancer d'une distance donnée</td>
    </tr>
    <tr>
      <td><code>backward(distance)</code></td>
      <td>Reculer d'une distance donnée</td>
    </tr>
    <tr>
      <td><code>up()</code></td>
      <td>Relever le crayon (pour pouvoir avancer sans dessiner)</td>
    </tr>
    <tr>
      <td><code>down()</code></td>
      <td>Abaisser le crayon</td>
    </tr>
    <tr>
      <td><code>color(couleur)</code></td>
      <td>Changer la couleur du crayon. <code>couleur</code> peut être un nom de couleur en anglais (<code>'red'</code>, <code>'blue'</code>, ...)</td>
    </tr>
    <tr>
      <td><code>left(angle)</code></td>
      <td>Tourner à gauche d'un angle donné (en degrés).</td>
    </tr>
    <tr>
      <td><code>right(angle)</code></td>
      <td>Tourner à droite d'un angle donné (en degrés).</td>
    </tr>
    <tr>
      <td><code>width(épaisseur)</code></td>
      <td>Changer l'épaisseur du crayon.</td>
    </tr>
    <tr>
      <td><code>goto(x, y)</code></td>
      <td>Aller à l'endroit de coordonnées x, y</td>
    </tr>
    <tr>
      <td><code>reset()</code></td>
      <td>Effacer tout</td>
    </tr>
    <tr>
      <td><code>done()</code></td>
      <td>Permet que la fenêtre de résultat reste ouverte une fois le dessin terminé.</td>
    </tr>
  </tbody>
</table>

<h3>Notre propre module</h3>
<p>Pour écrire un module, il suffit de créer un script contenant des définitions de fonctions. Comme exemple, nous allons créer un module nommé <code>shape</code> qui contiendra des fonctions permettant de dessiner des formes avec la « tortue ».</p>
<p>Nous créons donc un fichier nommé <code>shape.py</code> contenant le code suivant&nbsp;:</p>
<pre><code class="language-python">from turtle import ∗

def square(cote, couleur):
  color(couleur)
  for i in range(4):
    forward(cote)
    right(90)
</code></pre>
<p>On peut ensuite créer un programme qui utilise notre module&nbsp;:</p>
<pre><code class="language-python">from shape import ∗

up()
goto(−150, 50)

for i in range(10):
  down()
  square(25, &#39;red&#39;) 
  up()
  forward(30)

done()
</code></pre>
<p>Pour que le programme puisse trouver le module <code>shape</code>, il faut que les deux fichiers soient <strong>dans le même répertoire</strong>.</p>
<figure><img src="./squares.png" alt=""></figure>

<h3>La variable <code>__name__</code></h3>
<p>La variable globale <code>__name__</code> est définie dans chaque fichier Python. Elle contient un string égal au nom du module. Dans le programme principal (le fichier lancé avec la commande <code>python</code>), elle vaut <code>&quot;__main__&quot;</code>.</p>
<p>Pour avoir une partie d&#39;un module qui ne s&#39;exécute que quand on le lance comme un programme (quand on le lance directement avec la commande <code>python</code>), on teste souvent la variable <code>__name__</code>&nbsp;:</p>
<pre><code class="language-python"># à la fin du fichier shape.py
if __name__ == &quot;__main__&quot;:
    square(10, &#39;blue&#39;)
    done()
</code></pre>
<p>Le code ci-dessus permet de tester la fonction <code>square</code> en lançant le fichier shape.py&nbsp;:</p>
<div class="terminal">
> python shape.py
</div>

<p>Et cela affichera le carré bleu de côté 10.</p>
<p>Mais lorsqu&#39;on lancera le fichier qui importe <code>shape</code> et qui dessine 10 carrés rouges, le contenu du <code>if __name__ == &quot;__main__&quot;:</code> ne sera pas exécuté et le carré bleu ne sera pas affiché.</p>

</body>
</html>
