<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 2 - Valeurs, types et contrôle de flux</title>
    <script src="/document.js" defer></script>
    
</head>
<body>
    <h1>Chapitre 2 <small>Valeurs, types et contrôle de flux</small></h1>
    
    <script type="module" defer>
Doc.setChapterNb(2)
</script>

<h2>Variables, valeurs et types</h2>
<p>Dans le programme de résolution d&#39;équations du second degré, nous avons utilisé plusieurs variables, <code>a</code>, <code>b</code>, <code>c</code> et <code>D</code>.</p>
<p>Une variable est une sorte de boite possédant un nom et pouvant contenir une valeur. Pour mettre une valeur dans la variable, on utilise le signe <code>=</code>. Une fois la valeur de la variable définie, son contenu peut être utilisé dans le code en utilisant son nom.</p>
<pre><code class="language-python">a = 42
print(a) # affiche 42
</code></pre>
<p><em>Remarque: le caractère <code>#</code> permet d&#39;indiquer que le reste de la ligne est un commentaire. Les commentaires sont ignorés par l&#39;interpréteur Python.</em></p>
<figure id="variable" data-ref="figure">
<svg width="50%" viewBox="0 0 1780 941" version="1.1">
  <g>
    <rect
      x="718.473"
      y="186.234"
      width="511.1"
      height="511.1"
      style="fill: none; stroke: #000; stroke-width: 15.66px"
    />
    <text
      x="435.195px"
      y="507.148px"
      style="
        font-family: 'Consolas', monospace;
        font-size: 266.667px;
        fill: #008802;
      "
    >
      a
    </text>
    <text
      x="832.291px"
      y="528.046px"
      style="
        font-family: 'Consolas', monospace;
        font-size: 266.667px;
        fill: #0053d8;
      "
    >
      42
    </text>
    <ellipse
      cx="916.27"
      cy="448.593"
      rx="556.47"
      ry="374.94"
      style="fill: none; stroke: #de0000; stroke-width: 15.66px"
    />
    <text
      x="1207.1px"
      y="72.482px"
      style="font-size: 100px; fill: #de0000"
    >
      La variable
    </text>
    <text
      x="1366.77px"
      y="895.116px"
      style="font-size: 100px; fill: #0053d8"
    >
      La valeur
    </text>
    <text
      x="-6.862px"
      y="728.803px"
      style="font-size: 100px; fill: #008802"
    >
      Le nom
    </text>
    <path
      d="M483.334,598.628l23.199,-35.414l23.767,35.035"
      style="
        fill: none;
        stroke: #008802;
        stroke-width: 15.66px;
        stroke-linejoin: miter;
        stroke-miterlimit: 10;
      "
    />
    <path
      d="M359.8,693.598c138.621,-3.775 147.112,-42.337 146.733,-130.384"
      style="fill: none; stroke: #008802; stroke-width: 15.66px"
    />
    <path
      d="M950.341,624.014l24.803,-34.31l22.13,36.091"
      style="
        fill: none;
        stroke: #0053d8;
        stroke-width: 15.66px;
        stroke-linejoin: miter;
        stroke-miterlimit: 10;
      "
    />
    <path
      d="M1333.51,859.91c-199.807,-4.867 -365.219,-12.486 -358.367,-270.206"
      style="fill: none; stroke: #0053d8; stroke-width: 15.66px"
    />
  </g>
</svg>
<figcaption>Variable et valeur</figcaption>
</figure>

<p>Il est important ici de constater que le signe <code>=</code> a une signification très <strong>différente</strong> de ce que l&#39;on retrouve en <strong>mathématiques</strong>. En programmation, le <code>=</code> prend <strong>la valeur qui est à sa droite</strong> pour la mettre dans <strong>la variable qui est à sa gauche</strong>. Cela signifie que <code>42 = a</code> n&#39;a aucun sens en Python.</p>
<p>La valeur de la variable peut être modifiée en lui assignant une autre valeur.</p>
<pre><code class="language-python">a = 42
print(a) # affiche 42
a = 0
print(a) # affiche 0
</code></pre>
<p>Il y d&#39;autres moyens de mettre la valeur <code>42</code> dans la variable <code>a</code>&nbsp;:</p>
<pre><code class="language-python">a = 21 + 21
a = 2 * 21
# ...
</code></pre>
<p>La valeur qui est à droite du signe <code>=</code> peut être écrite directement; on parle alors d&#39;un <strong>littéral</strong>. Ou elle peut être le résultat d&#39;un calcul. Plus généralement, on appelle <strong>expression</strong> tout ce qui a une valeur. Un littéral est donc une expression mais toutes les expressions ne sont pas des littéraux.</p>
<h2>Types de valeurs</h2>
<p>Les valeurs peuvent être de différents types :</p>
<ul>
<li>Les entiers (<code>int</code>)</li>
</ul>
<pre><code class="language-python">a = 42 # littéral
a = 2 * 21 # expression
</code></pre>
<ul>
<li>Les nombres à virgule flottante (<code>float</code>)</li>
</ul>
<pre><code class="language-python">a = 0.42 # littéral
a = 42e-2 # littéral en notation scientifique
a = 1 / 2 # expression
</code></pre>
<ul>
<li>Les chaînes de caractères (<code>str</code>: <em>string</em>). Les <em>strings</em> sont un cas particulier d&#39;une famille de types plus générale qu&#39;on appelle <strong>les séquences</strong>.</li>
</ul>
<pre><code class="language-python">a = &quot;hello&quot; # littéral
b = &#39;coucou&#39; # littéral
c = 2 * a + &quot;!!&quot; # expression
</code></pre>
<ul>
<li>Les booléens (<code>bool</code>)</li>
</ul>
<pre><code class="language-python">a = True # littéral
b = a or 5 &lt; 0 # expression
</code></pre>
<ul>
<li><strong>Et bien d&#39;autres...</strong></li>
</ul>
<p>Physiquement, le contenu des variables est sauvé dans la <strong>RAM</strong> de l&#39;ordinateur. Dans la RAM, toutes les valeurs sont sauvegardées avec des <code>1</code> et des <code>0</code>. C&#39;est le <strong>type</strong> de la valeur qui indique à Python comment interpréter ces <code>1</code> et ces <code>0</code>.</p>
<p>Il est important de garder à l&#39;esprit les types des valeurs que l&#39;on manipule car les <strong>opérations</strong> que l&#39;on peut effectuer avec chaque type ne sont pas les mêmes et ne font pas toujours la même chose&nbsp;:</p>
<figure id='operations_type' data-ref='code'>

<pre><code class="language-python">i = 21
print(i + i) # affiche 42
s = &quot;21&quot;
print(s + s) # affiche 2121
print(i + s) # interdit
</code></pre>
<figcaption>Somme entre <code>int</code> et <code>float</code></figcaption>
</figure>

<p>Pour illustrer cela, apportons une petite modification au programme de résolution d&#39;équations du second degré. Bien que le programme fonctionne, il est nécessaire de modifier les définitions de <code>a</code>, <code>b</code> et <code>c</code> pour résoudre une autre équation. Ce n&#39;est pas idéal. Nous allons donc faire en sorte que le programme <strong>demande à l&#39;utilisateur</strong> d&#39;entrer les valeurs des coefficients de l&#39;équation. Pour cela, on utilise la fonction <code>input()</code>. Cette dernière <strong>interrompt</strong> l&#39;exécution du programme pour permettre à l&#39;utilisateur d&#39;entrer quelque chose au clavier. Elle laisse ensuite le programme <strong>reprendre</strong> et renvoie la valeur tapée&nbsp;:</p>
<figure id='python_2deg_corrected_2' data-ref='code'>

<pre><code class="language-python">from math import sqrt

a = input(&#39;entrez la valeur de a : &#39;)
b = input(&#39;entrez la valeur de b : &#39;)
c = input(&#39;entrez la valeur de c : &#39;)
D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution réelle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>Utilisation de <code>input</code></figcaption>
</figure>

<p>Relançons le programme et entrons les valeurs demandées&nbsp;:</p>
<pre class="terminal" style="font-size: 85%">
<b>> python 2nd_order.py</b>
entrez la valeur de a : 1
entrez la valeur de b : 0
entrez la valeur de c : -4
Traceback (most recent call last):
  File "C:\Users\lur\Programmation\2nd_order.py", line 5, in &lt;module&gt;
    D = b*b-4*a*c
        ~^~
TypeError: can't multiply sequence by non-int of type 'str'
</pre>

<p>Voilà un nouveau message d&#39;erreur ! Celui-ci nous indique que lors du calcul de <code>b*b</code>, on ne peut pas multiplier une séquence par une valeur de type <code>str</code>. On se rend compte ici que lorsqu&#39;on a tapé <code>0</code> pour indiquer la valeur de <code>b</code>, la fonction <code>input()</code> a renvoyé une valeur <strong>de type <code>str</code></strong>. Et cela pose problème pour la suite des calculs.</p>
<p>En fait, il s&#39;agit du comportement normal de la fonction <code>input()</code>. Comme cette fonction demande à l&#39;utilisateur d&#39;entrer quelque chose au clavier, elle ne fait que renvoyer la suite de caractères qui a été tapée. <strong><code>input()</code> renvoie donc toujours une valeur de type <code>str</code></strong>.</p>
<p>Pour pouvoir continuer les calculs, il faut <strong>convertir</strong> la chaîne de caractères en nombre. Comme l&#39;utilisateur pourrait taper des nombres à virgule, nous allons les convertir en <code>float</code>. Pour cela, il existe une fonction <code>float()</code> qui convertit ce qu&#39;elle reçoit en paramètre en valeur de type <code>float</code>.</p>
<p>Ajoutons donc la fonction <code>float()</code> à notre programme. Notez que l&#39;on peut directement utiliser la valeur renvoyée par <code>input()</code> comme <strong>paramètre</strong> de <code>float()</code>&nbsp;:</p>
<figure id='python_2deg_corrected_3' data-ref='code'>

<pre><code class="language-python">from math import sqrt

a = float(input(&#39;entrez la valeur de a : &#39;))
b = float(input(&#39;entrez la valeur de b : &#39;))
c = float(input(&#39;entrez la valeur de c : &#39;))
D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution réelle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>Utilisation de <code>float</code></figcaption>
</figure>

<p>Relançons le programme&nbsp;:</p>
<pre class="terminal">
<b>> python 2nd_order.py</b>
entrez la valeur de a : 1
entrez la valeur de b : 0
entrez la valeur de c : -4
La 1re racine est -2.0
La 2e racine est 2.0
</pre>

<p>Parfait !</p>
<p><strong>Dans un premier temps, les fonctions <code>input()</code> et <code>print()</code> seront nos seuls moyens de communication avec l&#39;utilisateur. On utilise <code>input()</code> pour recevoir des données de l&#39;utilisateur. Et on utilise <code>print()</code> pour afficher les résultats.</strong></p>
<h2>Expressions</h2>
<p>En programmation, une expression est tout ce qui a une valeur. On dit aussi qu&#39;une expression <strong>renvoie</strong> une valeur. Une expression peut donc être&nbsp;:</p>
<ul>
<li><strong>un littéral</strong>, c&#39;est-à-dire, une valeur écrite littéralement,</li>
</ul>
<pre><code class="language-python">42            # Littéral entier
3.141592      # Littéral flottant
&#39;Hello World&#39; # Littéral chaîne de caractères
True          # Littéral booléen
</code></pre>
<ul>
<li><strong>un nom de variable définie</strong>, dans ce cas la valeur de l&#39;expression est la valeur de la variable,</li>
</ul>
<pre><code class="language-python">a = 42        # Définition de la variable a
a             # expression valant 42
</code></pre>
<ul>
<li><strong>un appel de fonction</strong>, comme par exemple la fonction <code>sqrt</code>,</li>
</ul>
<pre><code class="language-python">from math import sqrt
sqrt(4)       # Expression valant 2.0
</code></pre>
<ul>
<li><strong>une combinaison d&#39;expressions</strong>, grâce à des opérateurs.</li>
</ul>
<h3>Opérateurs</h3>
<p>Comme nous l&#39;avons vu dans le <span data-link="operations_type">code</span>, les opérateurs disponibles et la façon de combiner les valeurs dépend de leurs types.</p>
<p>Les opérateurs suivants sont définis pour <strong>les valeurs numériques</strong>&nbsp;:</p>
<figure id='number_operators' data-ref='code'>

<pre><code class="language-python">1 + 2 # somme de deux nombres
1 - 2 # différence de deux nombres
2 * 2 # produit de deux nombres
4 ** 2 # puissance de deux nombres (ici 4²)
4 / 2 # quotient de deux nombres
5 // 2 # division entière
5 % 2 # modulo, reste de la division entière
</code></pre>
<figcaption>Opérations sur les nombres</figcaption>
</figure>

<p>Les deux dernières opérations nécessitent probablement un peu d&#39;explications. Lorsqu&#39;on parle de la division entière de <code>5</code> par <code>2</code>, on veut savoir combien de fois <code>2</code> entre <strong>entièrement</strong> dans <code>5</code>. <code>2</code> entre deux fois dans <code>5</code>, en effet, <code>2 x 2 ⇒ 4</code>. <code>2</code> n&#39;entre pas trois fois dans <code>5</code> car <code>3 x 2 ⇒ 6</code>, ce qui est plus grand que <code>5</code>.</p>
<p>Le <strong>reste</strong> de la division entière de <code>5</code> par <code>2</code> est la partie de <code>5</code> <strong>qui n&#39;a pas pu être divisée</strong> lors de la division entière. Comme on ne peut mettre que deux fois <code>2</code> dans <code>5</code> et que <code>2 x 2 ⇒ 4</code>, il reste <code>1</code> qui n&#39;a pas pu être divisé. On dit donc que le reste de la division entière de <code>5</code> par <code>2</code> est égale à <code>1</code>.</p>
<p>Souvenez-vous des divisions écrites que vous avez apprises en primaire. Si vous vous arrêtez avant de calculer les décimales, vous obtenez la division entière et le reste.</p>
<figure id="division" data-ref="figure">
<img src="./division_ecrite.svg" class="third">
<figcaption>Division écrite</figcaption>
</figure>

<p>Il y a plein de moments où la division entière et le modulo peuvent être utiles. Par exemple, si vous voulez convertir un nombre quelconque de minutes (disons 200) en heures/minutes. Pour obtenir le nombre d&#39;heures, il suffit de faire une division entière par 60: <code>200 // 60 ⇒ 3</code>. Nous avons donc 3 heures. Et pour obtenir le nombre de minutes restantes, on utilise le modulo 60: <code>200 % 60 ⇒ 20</code>. Il reste donc 20 minutes. 200 minutes correspondent à 3 heures et 20 minutes.</p>
<h3>Opérateurs de comparaison</h3>
<p>Les opérateurs de comparaison renvoient un <strong>booléen</strong> en fonction de deux valeurs à comparer. Par exemple <code>4 &lt; 3 ⇒ False</code> et <code>3.5 &gt; 0 ⇒ True</code>.</p>
<figure id='comparators' data-ref='code'>

<pre><code class="language-python">a &lt; b # inférieur à
a &gt; b # supérieur à
a &lt;= b # inférieur ou égal à
a &gt;= b # supérieur ou égal à
a == b # égal à
a != b # différent de
</code></pre>
<figcaption>Opérateurs de comparaison</figcaption>
</figure>

<p>Les comparaisons fonctionnent aussi sur les chaines de caractères. Un <code>str</code> est inférieur à un autre <code>str</code> s&#39;il vient avant dans l&#39;ordre alphabétique (<code>&#39;aab&#39; &lt; &#39;abc&#39; =&gt; True</code>).</p>
<h3>Opérateurs booléens</h3>
<p>Les opérateurs booléens permettent de <strong>combiner</strong> des valeurs booléennes entre elles. Ces opérateurs sont le <code>and</code>, le <code>or</code> et le <code>not</code>. La valeur renvoyée est aussi booléenne. Voici la <strong>table de vérité</strong> qui indique le résultat de chaque opération possible&nbsp;:</p>
<figure id="trues_table" data-ref='table'>
<table class='center'>
    <thead>
        <tr>
            <th><code>a</code></th>
            <th><code>b</code></th>
            <th><code>not a</code></th>
            <th><code>a and b</code></th>
            <th><code>a or b</code></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>True</code></td>
            <td><code>True</code></td>
            <td><code>False</code></td>
            <td><code>True</code></td>
            <td><code>True</code></td>
        </tr>
        <tr>
            <td><code>True</code></td>
            <td><code>False</code></td>
            <td><code>False</code></td>
            <td><code>False</code></td>
            <td><code>True</code></td>
        </tr>
        <tr>
            <td><code>False</code></td>
            <td><code>False</code></td>
            <td><code>True</code></td>
            <td><code>False</code></td>
            <td><code>False</code></td>
        </tr>
        <tr>
            <td><code>False</code></td>
            <td><code>True</code></td>
            <td><code>True</code></td>
            <td><code>False</code></td>
            <td><code>True</code></td>
        </tr>
    </tbody>
</table>
<figcaption>Table de vérité</figcaption>
</figure>

<h3>Priorité des opérateurs</h3>
<p>Il est bien sûr possible de combiner toutes ces opérations pour créer des expressions plus <strong>complexes</strong>. Il est intéressant de savoir que Python suit la même <strong>priorité</strong> des opérations que celle que vous avez vue en mathématiques (Les multiplications sont évaluées avant les additions). Voici, en détail, les priorités des opérations en Python (des plus prioritaires au moins prioritaires):</p>
<figure id="operation_precedence" data-ref='table'>
<table>
    <tr>
        <th>Opération</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>**</code></td>
        <td>Puissance</td>
    </tr>
    <tr>
        <td><code>-</code> </td>
        <td>Négatif (<code>-x</code>)</td>
    </tr>
    <tr>
        <td><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
        <td>Multiplication, Division, ...</td>
    </tr>
    <tr>
        <td><code>+</code>, <code>-</code></td>
        <td>Addition et soustraction</td>
    </tr>
    <tr>
        <td><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></td>
        <td>Comparaisons</td>
    </tr>
    <tr>
        <td><code>not</code></td>
        <td>NON booléen</td>
    </tr>
    <tr>
        <td><code>and</code></td>
        <td>ET Booléen</td>
    </tr>
    <tr>
        <td><code>or</code></td>
        <td>OU Booléen</td>
    </tr>
</table>
<figcaption>Priorité des opérations</figcaption>
</figure>

<p>Comme en mathématiques, il est possible d&#39;utiliser des <strong>parenthèses</strong> pour contrôler l&#39;ordre d&#39;évaluation des opérateurs. Nous en avons déjà utilisées dans le programme de résolution d&#39;équations du second degré, <code>(-b-sqrt(D))/(2*a)</code>.</p>
<p>Voici un exemple d&#39;expression complexe:</p>
<pre><code class="language-python">1 + 3.14 * 6 &lt;= 6 % 2**2 and &#39;aab&#39; &gt; &#39;abc&#39; or True == (not 42 != 21 + 21)
</code></pre>
<h2>Le contrôle de flux</h2>
<p>Les instructions d&#39;un programme s&#39;exécutent toujours <strong>dans l&#39;ordre</strong> dans lequel elles sont écrites dans le programme. On appelle cette séquence d&#39;instructions le <strong>flux</strong> du programme. Il est possible de réaliser des embranchements et des boucles dans ce flux.</p>
<h3>Les instructions conditionnelles</h3>
<p>Dans un programme, il est souvent intéressant d&#39;avoir des portions de code qui ne s&#39;exécutent que si certaines <strong>conditions sont remplies</strong>. Cela permet au programme de réagir en fonction des circonstances.</p>
<p>Pour cela, on utilise le <code>if</code>. Voici un exemple&nbsp;:</p>
<div class="row">
<div class="span6 middle">

<pre><code class="language-python">a = −5
if a &lt; 0:
   print(&quot;a est négatif&quot;)
</code></pre>
</div>
<div class="span6">
<figure id='if' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>if</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#if > div', 220, 300)
    const start = draw.start()
    const assign = draw.round('On met la valeur <code>-5</code> dans <code>a</code>').belowOf(start)
    const cond = draw.round('<code>a</code> est inférieur à 0&nbsp;?').belowOf(assign)
    const if1 = draw.diamond().belowOf(cond)
    const oui = draw.node('oui').belowOf(if1)
    const non = draw.node('non').absolute(if1, 50, 0)
    const disp = draw.round('Affiche <code>a est négatif</code>').belowOf(oui)
    const dummy = draw.dummy().rightOf(disp)
    const end = draw.end().belowOf(disp)
    draw.polyline([start, '-->', assign, '-->', cond, '-->', if1, '--', oui, '-->', disp, '-->', end])
    draw.polyline([if1, '--', non, '-|', dummy, '|->', end])
    draw.done()
</script>
</div>
</div>

<p>Nous pouvons voir qu&#39;il y a une condition après le <code>if</code>. Une <strong>condition</strong> est une expression dont la valeur est <strong>booléenne</strong>.</p>
<p>L&#39;instruction <code>if</code> est le premier exemple d&#39;<strong>instruction composée</strong> que nous rencontrons. Une instruction composée comporte une ligne d&#39;en-tête se terminant par un <code>:</code> suivie d&#39;un bloc d&#39;instructions <strong>indenté</strong> <em>(décalé vers la droite)</em>.</p>
<figure id="indentation" data-ref="figure">
<img src="./indentation.svg" class='half'>
<figcaption>Instruction composée</figcaption>
</figure>

<p><strong>Attention : toutes les instructions du bloc doivent être indentées de la même manière. En particulier, on ne peut pas indenter une ligne avec des espaces et une autre avec des tabulations même si cela semble visuellement identique ! Dans VSCode, il est possible d&#39;activer l&#39;affichage des caractères blancs pour identifier plus facilement les espaces et les tabulations.</strong></p>
<p>Il est possible de définir un bloc à exécuter si la condition est fausse avec l&#39;instruction <code>else</code> <em>(sinon)</em>&nbsp;:</p>
<div class="row">
<div class="span5 middle">

<pre><code class="language-python">a = −5
if a &lt; 0:
   print(&quot;a est négatif&quot;)
else:
   print(&quot;a est positif&quot;)
</code></pre>
</div>
<div class="span7">
<figure id='if_else' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>if else</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#if_else > div', 350, 350)
    const start = draw.start().move(1, 2)
    const assign = draw.round('On met la valeur <code>-5</code> dans <code>a</code>').belowOf(start)
    const cond = draw.round('<code>a</code> est inférieur à 0&nbsp;?').belowOf(assign)
    const if1 = draw.diamond().belowOf(cond)
    const oui = draw.node('oui').belowOf(if1)
    const non = draw.node('non').absolute(if1, 50, 0)
    const dispOui = draw.round('Affiche <code>a est négatif</code>').belowOf(oui)
    const dispNon = draw.round('Affiche <code>a est positif</code>').rightOf(oui)
    const end = draw.end().belowOf(dispOui)
    draw.polyline([start, '-->', assign, '-->', cond, '-->', if1, '--', oui, '-->', dispOui, '-->', end])
    draw.polyline([if1, '--', non, '-|>', dispNon, '|->', end])
    draw.done()
</script>
</div>
</div>

<p>L&#39;instruction <code>elif</code> (contraction de &quot;<code>else if</code>&quot;) permet d&#39;avoir plus de deux branches&nbsp;:</p>
<pre><code class="language-python">a = −5
if a == 0:
   print(&quot;a est nul&quot;)
elif a &lt; 0:
   print(&quot;a est négatif&quot;)
else:
   print(&quot;a est positif&quot;)
</code></pre>
<figure id='if_elif_else' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>if elif else</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#if_elif_else > div', 550, 300)
    const start = draw.start().move(1, 2)
    const assign = draw.round('On met la valeur <code>-5</code> dans <code>a</code>').belowOf(start)
    const if1 = draw.diamond().belowOf(assign)
    const neg = draw.node('<s>a == 0</s><br>a < 0').belowOf(if1)
    const pos = draw.node('<s>a == 0<br>a < 0</s>').rightOf(if1)
    const nul = draw.node('a == 0').leftOf(if1)
    const dispNeg = draw.round('Affiche <code>a est négatif</code>').belowOf(neg)
    const dispPos = draw.round('Affiche <code>a est positif</code>').rightOf(neg)
    const dispNul = draw.round('Affiche <code>a est nul</code>').leftOf(neg)
    const end = draw.end().belowOf(dispNeg)
    draw.polyline([start, '-->', assign, '-->', if1, '--', neg, '-->', dispNeg, '-->', end])
    draw.polyline([if1, '--', pos, '-->', dispPos, '|->', end])
    draw.polyline([if1, '--', nul, '-->', dispNul, '|->', end])
    draw.done()
</script>

<p>Dans ce dernier exemple, il est important de comprendre que Python choisit <strong>la première branche pour laquelle la condition est vraie</strong>. Si la première condition <code class="nowrap">a == 0</code> est vraie, alors la deuxième condition n&#39;est même pas évaluée. Par contre, si on arrive dans la deuxième branche, celle du <code>elif</code>, cela <strong>implique</strong> que la première condition était fausse et donc que <code>a != 0</code>.</p>
<h3>Les boucles</h3>
<p>Dans un programme, il arrive très souvent qu&#39;il faille exécuter une même portion de code un certain nombre de fois. C&#39;est d&#39;ailleurs un des grands points forts de l&#39;informatique : <strong>exécuter des opérations répétitives à une vitesse prodigieuse</strong>.</p>
<p>Pour réaliser une boucle dans le flux d&#39;exécution du programme, on utilise l&#39;instruction composée <code>while</code>&nbsp;:</p>
<div class="row">
<div class="span5 middle">

<pre><code class="language-python">i = 0
while i &lt; 5:
    i = i + 1
    print(i)
</code></pre>
</div>
<div class="span7">
<figure id='while' data-ref='figure'>
    <div></div>
    <figcaption>Le <code>while</code></figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#while > div', 350, 350)
    const start = draw.start().move(1, 2)
    const init = draw.round('Met la valeur <code>0</code> dans <code>i</code>').belowOf(start)
    const back = draw.dummy().belowOf(init)
    const cond = draw.round('i < 5 ?').belowOf(back)
    const if1 = draw.diamond().belowOf(cond)
    const oui = draw.node('oui').belowOf(if1)
    const non = draw.node('non').rightOf(if1)
    const dummy = draw.dummy().leftOf(if1)
    const inc = draw.round('Incrémente <code>i</code>').belowOf(oui)
    const show = draw.round('Affiche la valeur de <code>i</code>').belowOf(inc)
    const end = draw.end().belowOf(show)
    draw.polyline([start, '-->', init, '--', back, '-->', cond, '-->', if1, '--', oui, '-->', inc, '-->', show, '-|', dummy, '|->', back])
    draw.polyline([if1, '--', non, '|->' , end])
    draw.done()
</script>
</div>
</div>

<p><strong>L&#39;instruction while exécute son bloc tant que sa condition est vraie.</strong></p>
<p>Dans ce cas-ci, le bloc commence par l&#39;incrémentation de <code>i</code>. Cette instruction nécessite une petite explication. Il s&#39;agit ici encore d&#39;un exemple flagrant de la différence qu&#39;il existe entre le <code>=</code> de la programmation et le <code>=</code> des mathématiques. En effet, l&#39;expression <code>i = i + 1</code> n&#39;a <strong>aucun sens en mathématiques</strong>. Elle est cependant parfaitement valide <em>(et très courante)</em> en programmation. Elle signifie &quot;mettre la valeur de l&#39;expression <code>i + 1</code> <em>(quelle que soit la valeur de <code>i</code>)</em> dans la variable <code>i</code>&quot;. Il faut comprendre ici que la valeur de l&#39;expression <code>i + 1</code> <strong>est calculée d&#39;abord</strong>. Puis, cette valeur est assignée à <code>i</code> c&#39;est-à-dire qu&#39;elle va remplacer la valeur qu&#39;avait <code>i</code>. En bref, l&#39;instruction <code>i = i + 1</code> augmente la valeur de <code>i</code> de <code>1</code>.</p>
<p>Le bloc se termine par l&#39;affichage de <code>i</code>.</p>
<p>Nous avons donc un bloc d&#39;instructions qui sera répété tant que <code>i</code> sera inférieur à <code>5</code> et ce bloc incrémente puis affiche <code>i</code>. Comme <code>i</code> démarre à <code>0</code>, l&#39;affichage final sera le suivant&nbsp;:</p>
<div class="terminal">
1
2
3
4
5
</div>

<p>Il est à noter que la condition du <code>while</code> est testée <strong>avant le début de chaque tour de boucle</strong>. Il peut donc arriver que la boucle ne fasse aucun tour si la condition est fausse dès le départ.</p>
<p><strong>Il est bien sûr évident qu&#39;il faut s&#39;arranger pour que la condition ne soit pas vraie pour toujours car, dans ces conditions, la boucle ne s&#39;arrêterait jamais et le programme serait bloqué.</strong></p>
<pre><code class="language-python">n = 1
while n &lt;= 5:
   print(n)      # boucle infinie !!
</code></pre>
<pre><code class="language-python">n = 1
while n &gt; 0:
   print(n)
   n += 1        # boucle infinie !!
</code></pre>
<p>Il est également possible de contrôler le déroulement de la boucle à partir de l&#39;intérieur du bloc avec les instructions <code>break</code> et <code>continue</code>.</p>
<p>L&#39;instruction <code>break</code> permet de mettre <strong>immédiatement</strong> fin à la boucle&nbsp;:</p>
<pre><code class="language-python"># recherche le plus petit naturel non nul divisible par 38 et 46
n = 1
while True:
   if n % 38 == 0 and n % 46 == 0:
      break
   n += 1
print(n, &quot;est le plus petit nombre divisible par 38 et 46&quot;)
</code></pre>
<p>L&#39;instruction <code>continue</code> permet de mettre immédiatement fin au tour de boucle <strong>en cours</strong>&nbsp;:</p>
<pre><code class="language-python"># affiche tous les nombres pairs plus petits que 100
n = 0
while n &lt;= 100:
   n += 1
   if n % 2 != 0:
      continue
   print(n)
</code></pre>

</body>
</html>
