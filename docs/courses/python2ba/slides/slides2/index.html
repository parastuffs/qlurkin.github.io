<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Chapitre 02 - Imbrication de données et Objets</title>
	<script src="/deck.js" defer></script>
	<style>
		pre > code {
			font-size: 75% !important;
		}
	</style>
</head>
<body>
	<section>
		<h1>IN2T - Informatique <small>Imbrication de données et Objets</small></h1>
		<p>Quentin Lurkin</p>
	</section>

	<section class="full">
		<h2>Imbrication de données</h2>
		<img src="images/4577032677_1106406a0f_b.jpg">
	</section>

	<section>
		<h2>Imbrication de données</h2>
		
		
		<ul>
			<li>
				<strong>Imbriquer</strong> des données 
				
				<small>Insertion d'une structure de données comme élément d'une autre</small>
			</li>
			<li>
				<strong>Contraintes</strong> selon la structure principale 
				
				<small>Éléments d'un ensemble et clés d'un dictionnaire non modifiables</small>
			</li>
			<li>
				Représentation de <strong>données complexes</strong> 
				
				<small>Bien organiser et définir la structure de données</small>
			</li>
		</ul>
		
		
	</section>
	<section>
		<h2>Liste à deux dimensions</h2>
		
		
		<ul>
			<li>
				On peut construire une liste dont les <strong>éléments sont des listes</strong>
			</li>
			<li>
				<strong>Accès multiples</strong> à faire pour accéder aux éléments imbriqués
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			A = [1, 2]
			B = [3, 4, 5]
			L = [A, B]                # Équivalent à L = [[1, 2], [3, 4, 5]]
			
			print(L[0][1])            # 2
			print(L[1][2])            # 5
		</code></pre>
		
		<figure>
			<img src="images/imbrication.svg" style="width: 20em">
		</figure>
		
	</section>
	<section>
		<h2>Parcours d'une liste à deux dimensions</h2>
		
		
		<ul>
			<li>
				Parcours à l'aide d'une <strong>double boucle</strong> 
				
				<small>Imbrication d'une boucle dans une autre, <code>while</code> ou <code>for</code></small>
			</li>
			<li>
				La première boucle passe en revue les <strong>listes imbriquées</strong> 
				
				<small>La seconde boucle parcourt les éléments de chaque liste imbriquée</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			L = [[1, 2], [3, 4, 5]]
			
			for elem in L:               # elem est une liste
				for data in elem:        # data est un nombre entier
					print(data, end=' ')
				print('| ', end='')
		</code></pre>
		<pre><code class="lang-plaintext">
			1 2 | 3 4 5 | 
		</code></pre>
		
	</section>
	<section>
		<h2>Représentation d'une matrice</h2>
		
		
		<ul>
			<li>
				<strong>Matrice</strong> représentée par une liste à deux dimensions 
				
				<small>Toutes les listes imbriquées ont le même nombre d'éléments</small>
			</li>
			<li>
				Stockage d'une <strong>liste des lignes</strong> de la matrice 
				
				<ul>
					<li>
						La première dimension représente les lignes
					</li>
					<li>
						Colonnes représentées par la deuxième dimension
					</li>
				</ul>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			M = [[1, 2, 3], [4, 5, 6]]
		</code></pre>
		
		\[ M = \left(\begin{array}{ccc} 1 & 2 & 3 \\ 4 & 5 & 6 \end{array}\right) \qquad \textsf{Par exemple, \texttt{M[1][0]} vaut 4} \]
		
	</section>
	<section>
		<h2>Parcours d'une matrice</h2>
		
		
		<ul>
			<li>
				<strong>Dimension</strong> de la matrice obtenue avec la fonction <code>len</code> 
				
				<small>La matrice a <code>len(M)</code> lignes et <code>len(M[0])</code> colonnes</small>
			</li>
			<li>
				<strong>Parcours</strong> avec boucle <code>while</code> et indices ou avec boucle <code>for</code>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			# Avec une boucle while
			i = 0
			while i < len(M):
				j = 0
				while j < len(M[0]):
					print(M[i][j])
					j += 1
				i += 1
			
			# Avec une boucle for
			for line in M:
				for elem in line:
					print(elem)
		</code></pre>
		
	</section>
	<section>
		<h2>Structures imbriquées (1)</h2>
		
		
		<ul>
			<li>
				Imbrication d'autres structures <strong>dans des listes</strong> 
				
				<small>Liste de tuples, ensembles et dictionnaires</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			# Liste de tuples
			coords = [(0,0), (7,-2), (4,5), (-3,-9)]
			
			# Liste d'ensembles
			lunches = [
				{'apple', 'banana', 'grape'},
				{'yogurt', 'cereals'},
				{'bread', 'cheese', 'ham'},
				{'sausage'}
			]
			
			# Liste de dictionnaires
			contacts = [
				{'firstname': 'Alexis', 'lastname': 'King'},
				{'firstname': 'Brice', 'lastname': 'Monster'},
				{'firstname': 'Sébastien', 'lastname': 'Adams'}
			]
		</code></pre>
		
	</section>
	<section>
		<h2>Structures imbriquées (2)</h2>
		
		
		<ul>
			<li>
				Structures imbriquées en <strong>clés et valeurs</strong> de dictionnaires 
				
				<small>Les clés d'un dictionnaire doivent être non modifiables</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			# Tuples en clés d'un dictionnaire
			config = {
				(0, 0): 'Arnaud',
				(2, 1): 'Louis',
				(-1, 3): 'Marie',
				(3, -1): 'Dan'
			}
			
			# Listes en valeurs d'un dictionnaire
			config = {
				(0, 0): ['Arnaud', 'Pierre'],
				(2, 1): ['Louis'],
				(-1, 3): ['Marie', 'Éric', 'Tom'],
				(3, -1): ['Dan']
			}
		</code></pre>
		
	</section>
	<section>
		<h2>Imbrication complexes</h2>
		
		
		<ul>
			<li>
				On peut <strong>imbriquer</strong> des structures à plusieurs niveaux 
				
				<small>Des séquences, ensembles et dictionnaires</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			address = {'street': "Promenade de l'Alma", 'number': 50,
				'zip': 1200, 'city': "Woluwé-Saint-Lambert"}
			marchand = {'firstname': "Cédric", 'lastname': "Marchand",
				'address': address}
			
			# Équivalent à
			# marchand = {'firstname': "Cédric", 'lastname': "Marchand", 
			#    'address': {'street': "Promenade de l'Alma", 'number': 50, 
			#    'zip': 1200, 'city': "Woluwé-Saint-Lambert"}}
			
			print(marchand['firstname'])            # Cédric
			print(marchand['address']['city'])      # Woluwé-Saint-Lambert
		</code></pre>
		
	</section>
	<section>
		<h2>Copie (1)</h2>
		
		
		<ul>
			<li>
				Affecter une même liste à deux variables crée un <strong>alias</strong> 
				
				<small>Même chose pour les séquences, les ensembles et les dictionnaires</small>
			</li>
			<li>
				On crée une <strong>véritable copie</strong> de liste avec la fonction <code>list</code> 
				
				<small>Ou avec les fonctions <code>set</code>, <code>dict</code>...</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			L = [1, 2, 3, 4, 5]
			A = L                                   # A est un alias de L
			A[0] = 42
			print(L)                                # [42, 2, 3, 4, 5]
			
			L = [1, 2, 3, 4, 5]
			B = list(L)                             # B est une copie de L
			B[0] = 42
			print(L)                                # [1, 2, 3, 4, 5]
		</code></pre>
		
	</section>
	<section>
		<h2>Copie (2)</h2>
		
		<figure>
			<img src="images/alias.svg" style="width: 25em">
		</figure>
		
	</section>
	<section>
		<h2>Copie de structures imbriquées</h2>
		
		
		<ul>
			<li>
				Pas de soucis de copies pour les <strong>collections non modifiables</strong>
			</li>
			<li>
				La copie ne se fait <strong>pas en profondeur</strong> 
				
				<small>Seuls les éléments de \og premier niveau \fg{</small> sont copiés}
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			L = [[1, 2], [3, 4, 5]]
			A = list(L)
			
			A[1][0] = 42
			print(L)                           # [[1, 2], [42, 4, 5]]
		</code></pre>
		
		<figure>
			<img src="images/shallow.svg" style="width: 20em">
		</figure>
		
	</section>
	<section>
		<h2>Module <code>copy</code></h2>
		
		
		<ul>
			<li>
				Deux fonctions proposées par le <strong>module <code>copy</code></strong> 
				
				<ul>
					<li>
						<code>copy</code> pour une copie "<i>shallow</i>"
					</li>
					<li>
						<code>deepcopy</code> pour une copie "<i>deep</i>"
					</li>
				</ul>
			</li>
			<li>
				Une <strong>copie en profondeur</strong> peut prendre du temps 
				
				<small>Et aussi consommer beaucoup d'espace mémoire</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			import copy
			
			L = [[1], [2, 3], [4, 5, 6]]
			A = copy.copy(L)                   # A est une copie shallow de L
			B = copy.deepcopy(L)               # A est une copie deep de L
		</code></pre>
		
	</section>
	
	<section class="full">
		<h2>Objets</h2>
		<img src="images/2828893154_94b10b0822_o.jpg">
	</section>
	<section>
		<h2>Objet (1)</h2>

		<ul>
			<li>
				Un <strong>objet</strong> combine des données et des fonctions 
				
				<small>Les fonctions ont accès complet aux données de l'objet</small>
			</li>
			<li>
				Permet de définir des <strong>types de données</strong> complexes 
				
				<small>On a déjà renconté les listes, chaines de caractères, ensembles...</small>
			</li>
		</ul>


		<pre><code class="lang-python">
			dice = {1, 2, 3, 4, 5, 6}            # Initialisation des données
			face = dice.pop()                    # Appel d'une fonction
			
			print("La face visible du dé est :", face)
		</code></pre>

		<pre><code class="lang-plaintext">
			La face visible du dé est : 1
		</code></pre>

	</section>
	<section>
		<h2>Objet (2)</h2>


		<ul>
			<li>
				<strong>Trois éléments</strong> existent lorsqu'on crée un objet 
				
				<ul>
					<li>
						L'<b>objet</b>, avec ses attributs, se trouve en mémoire
					</li>
					<li>
						Une <b>variable</b> du même type que l'objet est déclarée
					</li>
					<li>
						Une <b>référence</b> vers l'objet est stockée dans la variable
					</li>
				</ul>
			</li>
		</ul>


		<pre><code class="lang-python">
			dice = {1, 2, 3, 4, 5, 6}
		</code></pre>

		<figure>
			<img src="images/dice.svg" class="third">
		</figure>

	</section>
	<section>
		<h2>Création</h2>


		<ul>
			<li>
				Création d'un objet en exécutant un <strong>constructeur</strong> 
				
				<small>Permet d'initialiser les attributs de l'objet</small>
			</li>
		</ul>


		<pre><code class="lang-python">
			from datetime import time
			
			start = time(14, 45, 21)
			end = time(16, 15, 56)
		</code></pre>

		<figure>
			<img src="images/time.svg" class="third2">
		</figure>

	</section>
	<section>
		<h2>Accès aux attributs</h2>

		<ul>
			<li>
				<strong>Accès aux attributs</strong> d'un objet avec l'opérateur d'accès (<code>.</code>)
			</li>
			<li>
				L'accès peut se faire en <strong>lecture et/ou écriture</strong> 
				
				<small>Certains attributs sont protégés et en lecture seule</small>
			</li>
		</ul>


		<pre><code class="lang-python">
			startseconds = 3600 * start.hour + 60 * start.minute + start.second
			endseconds = 3600 * end.hour + 60 * end.minute + end.second
			
			difference = endseconds - startseconds
			print("Le cours va durer :", difference, "secondes")
		</code></pre>

	</section>
	<section>
	<h2>Attribut en lecture seule</h2>


	<ul>
		<li>
			Erreur d'exécution si <strong>modification attribut lecture seule</strong> 
			
			<small>Modification d'un attribut faite par affectation</small>
		</li>
	</ul>


	<pre><code class="lang-python">
		from datetime import time
		
		start = time(14, 45, 21)
		start.minute = 15
	</code></pre>

	<pre><code class="lang-plaintext">
		Traceback (most recent call last):
			File "program.py", line 4, in <module>
				start.minute = 15
		AttributeError: attribute 'minute' of 'datetime.time' objects is
		not writable
		</code></pre>
		
	</section>
	<section>
		<h2>Paramètre de type objet</h2>
		
		<ul>
			<li>
				Une fonction peut recevoir des <strong>paramètres de type objet</strong> 
				
				<small>Le paramètre reçoit une copie de la référence vers l'objet</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			from datetime import time
			
			def toseconds(t):
				return 3600 * t.hour + 60 * t.minute + t.second
			
			
			start = time(14, 45, 21)
			end = time(16, 15, 56)
			
			difference = toseconds(end) - toseconds(start)
			print("Le cours va durer :", difference, "secondes")
		</code></pre>
		
		<pre><code class="lang-plaintext">
			Le cours va durer : 5435 secondes
		</code></pre>
		
	</section>
	<section>
		<h2>Valeur de retour de type objet</h2>
		
		
		<ul>
			<li>
				Une fonction peut <strong>renvoyer un objet</strong> 
				
				<small>La fonction crée l'objet et renvoie une référence vers ce dernier</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			from datetime import time
			
			def theoreticalend(start, duration):
				minute = start.minute + (duration % 60)
				hour = start.hour + (duration // 60) + (minute // 60)
				return time(hour, minute % 60, start.second)
			
			
			start = time(14, 45, 21)
			print("Le cours devrait finir à :", theoreticalend(start, 90))
		</code></pre>
		
		<pre><code class="lang-plaintext">
			Le cours devrait finir à : 16:15:21
		</code></pre>
		
	</section>
	<section>
		<h2>Appel de méthode (1)</h2>
		
		
		<ul>
			<li>
				Une fonction associée à un objet est appelée une <strong>méthode</strong> 
				
				<small>Une méthode est appelée sur un objet cible</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			from calendar import TextCalendar
			
			cal = TextCalendar()
			cal.prmonth(2015, 9)      # Affiche le calendrier de septembre 2015
		</code></pre>
		
		<pre><code class="lang-plaintext">
			September 2015
			Mo Tu We Th Fr Sa Su
			    1  2  3  4  5  6
			 7  8  9 10 11 12 13
			14 15 16 17 18 19 20
			21 22 23 24 25 26 27
			28 29 30
		</code></pre>
		
	</section>
	<section>
		<h2>Appel de méthode (2)</h2>
		
		
		<ul>
			<li>
				Méthode appelée avec l'<strong>opérateur d'appel de méthode</strong> (<code>.</code>) 
				
				<small>L'objet cible est précisé avant le point</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			from calendar import TextCalendar
			
			cal = TextCalendar()
			cal.setfirstweekday(6)    # Change le premier jour de la semaine
			cal.prmonth(2015, 9)
		</code></pre>
		
		<pre><code class="lang-plaintext">
			September 2015
			Su Mo Tu We Th Fr Sa
			       1  2  3  4  5
			 6  7  8  9 10 11 12
			13 14 15 16 17 18 19
			20 21 22 23 24 25 26
			27 28 29 30
		</code></pre>
		
	</section>

	<section>
		<h2>Programmation orientée objet</h2>
		
		
		<ul>
			<li>
				La <strong>programmation orientée objet</strong> manipule des objets 
				
				<small>Concepts et entités représentés par des objets</small>
			</li>
			<li>
				Représenter des objets <strong>concrets ou conceptuels</strong> du monde réel 
				
				<small>Une personne, un moyen de transport, une date, une liste...</small>
			</li>
			<li>
				Création de <strong>nouveaux types de données</strong> 
				
				<small>Permet une programmation de plus haut niveau</small>
			</li>
		</ul>
		
		
	</section>
	<section>
		<h2>État d'un objet</h2>
		
		
		<ul>
			<li>
				Chaque objet est unique et possède son propre <strong>état</strong> 
				
				<small>Identité propre à chaque objet, avec ses propres attributs</small>
			</li>
			<li>
				L'état d'un objet est <strong>modifiable ou non</strong> 
				
				<ul>
					<li>
						Objet immuable aura toujours le même état
					</li>
					<li>
						État d'un objet non modifiable ne peut être changé
					</li>
				</ul>
			</li>
		</ul>
		
		
	</section>
	<section>
		<h2>Identité d'un objet</h2>
		
		
		<ul>
			<li>
				<strong>Identité</strong> d'un objet propre à chaque objet créé 
				
				<small>Caractérisée par son emplacement en mémoire</small>
			</li>
			<li>
				Fonction prédéfinie <strong><code>id</code></strong> renvoie l'identité
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			numbers = {8, 3, 1, -2, 0}
			letters = {'A', 'P', 'Q'}
			
			print(id(numbers))
			print(id(letters))
		</code></pre>
		
		<pre><code class="lang-plaintext">
			4302577224
			4329799752
		</code></pre>
		
	</section>
	<section>
		<h2>Tout est objet (1)</h2>
		
		
		<ul>
			<li>
				En Python, toute donnée est un <strong>objet</strong> 
				
				<small>Même tout ce qu'on a déjà vu comme les nombres, booléens...</small>
			</li>
			<li>
				Fonction prédéfinie <strong><code>dir</code></strong> donne la liste des méthodes
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			temperature = 19
			print(dir(temperature))
		</code></pre>
		
		<pre><code class="lang-plaintext">
			['__abs__', '__add__', '__and__', '__bool__', '__ceil__',
			'__class__', '__delattr__', '__dir__', '__divmod__', '__doc__',
			'__eq__', '__float__', '__floor__', '__floordiv__', '__format__',
			'__ge__', '__getattribute__', '__getnewargs__', '__gt__',
			'__hash__', '__index__', '__init__', '__int__', '__invert__',
			'__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__',
			'__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__',
			'__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__',
			'__repr__', '__rfloordiv__', '__rlshift__', '__rmod__',
			'__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__',
			'__rshift__', '__rsub__', '__rtruediv__', '__rxor__',
			'__setattr__', '__sizeof__', '__str__', '__sub__',
			'__subclasshook__', '__truediv__', '__trunc__', '__xor__',
			'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag',
			'numerator', 'real', 'to_bytes']
		</code></pre>
		
	</section>
	<section>
		<h2>Tout est objet (2)</h2>
		
		
		<ul>
			<li>
				Les nombres entiers ont une <strong>méthode <code>__add__</code></strong> 
				
				<small>Permet de faire la somme de deux entiers</small>
			</li>
			<li>
				Appel à la méthode <code>__add__</code> simplifié par l'<strong>opérateur <code>+</code></strong> 
				
				<small>Redéfinition d'un opérateur rend le code plus lisible</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			print(temperature + 11)
			print(temperature.__add__(11))
		</code></pre>
		
		<pre><code class="lang-plaintext">
			30
		</code></pre>
		
	</section>
	<section>
		<h2>Exemple : les complexes</h2>
		
		
		<ul>
			<li>
				<strong>Nombre complexe</strong> représenté par des objets de type <code>complex</code> 
				
				<small>Deux façons de les créer puis on peut utiliser plusieurs méthodes</small>
			</li>
		</ul>
		
		
		<pre><code class="lang-python">
			a = 2 + 3j
			b = complex(-1, 4)
			
			print(type(a))
			print(a.imag)
			print(b.conjugate())
		</code></pre>
		
		<pre><code class="lang-plaintext">
			<class 'complex'>
				3.0
				(-1-4j)
			</code></pre>
			
		</section>
		<section>
			<h2>Exemple : les chaines de caractères</h2>
			
			
			<ul>
				<li>
					<strong>Chaine de caractères</strong> représenté par des objets de type <code>str</code> 
					
					<small>Myriade de méthodes permettant de les manipuler</small>
				</li>
			</ul>
			
			
			<pre><code class="lang-python">
				s = "heLLo"
				
				print(s.upper())
				print(s.capitalize())
				print(s.startswith("H"))
			</code></pre>
			
			<pre><code class="lang-plaintext">
				HELLO
				Hello
				False
			</code></pre>
			
		</section>
		<section>
			<h2>Exemple : le navigateur web</h2>
			
			
			<ul>
				<li>
					Module <code>webbrowser</code> permet de manipuler le <strong>navigateur web</strong> 
					
					<small>Récupération du navigateur puis ouverture de pages avec <code>open</code></small>
				</li>
			</ul>
			
			
			<pre><code class="lang-python">
				import webbrowser
				
				chrome = webbrowser.get()
				chrome.open("http://www.ukonline.be")
			</code></pre>
			
		</section>
		<section>
			<h2>Crédits</h2>
			
			<ul>
				<li>
					https://www.flickr.com/photos/madalena_pestana/2828893154
				</li>
				<li>
					https://www.flickr.com/photos/ken-ichi/4577032677
				</li>
			</ul>
		
	</section>
	
</body>
</html>
								
