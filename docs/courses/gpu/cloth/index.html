<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SA4L - Projet</title>
	<script src="/document.js" defer></script>
</head>
<body>
	<h1>SA4L - Projet <small>Cloth Simulation</small></h1>
	<h2>Enonc√©</h2>
	<p>In this projet you will create a simulation of cloth in Rust. The cloth will be just a subdivided plane.</p>
	<figure>
		<img src="mesh.png" alt="Wireframe render of a flat cloth">
	</figure>
	<p>You will use a Compute Shader to update the positions and velocities of the vertices of the cloth. Your simulation will have to detect collisions between the cloth and a sphere and make the cloth react in a realistic way.</p>
	<figure>
		<img src="tissu.png" alt="">
	</figure>
	<p>The cloth geometry and the springs connectivity will be generated by Rust code on the CPU. The simulation must run on the GPU with a Compute Shader. Simulations parameters must come from the Rust code via an Uniform Buffer.</p>

	<p>The project will have to be defended during the oral exam in January.</p>

	<h2>Cloth Simulation</h2>
	<p>In a cloth simulation, only the motion of individual vertices is calculated. Each vertex is considered as a point body with a mass, a position and a velocity. At each time step, we calculate the forces that apply on the vertex. The resultant of the forces allows us to calculate the acceleration. The acceleration allows us to update the velocity. The velocity allows us to update the position. $$ \begin{aligned} \vec{v_c} &= \vec{v_p} + \Delta{}t \; \frac{\vec{R}}{m} \\ \vec{x_c} &= \vec{x_p} + \Delta{}t \; \vec{v_c} \end{aligned}$$</p>
	<p>Where \(\vec{x_c}\) and \(\vec{x_p}\) are respectively the positions in the current frame and in the previous frame. Idem for \(\vec{v_c}\) and \(\vec{v_p}\) that are velocities. \(\vec{R}\) is the resultant of the forces and \(m\) the mass. \(\Delta{}t\) is the time step. If we want a stable simulation we will need to compute <strong>multiple time steps between each frame</strong>.</p>
	
	<p>What are the forces that apply in a simulation of a cloth? To make a simple simulation, we consider that the different vertices of the cloth are connected by springs. The forces are easily calculated using Hooke's law. $$\vec{F_s} = - k \; \Delta{}l$$</p>
	<p>Where \(k\) is the spring stiffness constant and \(\Delta{}l\) the difference in length compared to the length of the spring at rest. the \(-\) sign is there to remind us that the force opposes the length variation and therefore acts to bring the spring back to its rest length.</p>

	<p>To obtain a realistic behavior it is necessary to have three types of springs in a cloth.</p>
	<figure>
		<img src="Three-types-of-basic-springs-for-cloth-simulation.png" alt="">
	</figure>
	<p>The stiffness constants of these three types of springs are generally different.</p>

	<p>The problem with springs is that they have an annoying tendency to oscillate. To reduce this problem, a damping force is added. This force resists the movement of the vertex and is proportional to the velocity. $$ \vec{F_d} = -c_d \; \vec{v} $$ </p>
	<p>Where \(c_d\) is the damping coefficient.</p>

	<p>For the cloth to fall, gravity must obviously be taken into account. $$ F_g = m \; \vec{g} $$</p>

	<p>During the contact between the cloth and the sphere, it is possible to take into account frictional forces. The friction is tangent to the friction surface and is calculated on the basis of the resultant of the other forces. $$ \begin{aligned} \vec{R_{o_n}} &= (\vec{R_{o}} \cdot \vec{1_n}) \; \vec{1_n} \\ \vec{R_{o_t}} &= \vec{R_{o}} - \vec{R_{o_n}} \\ \vec{1_t} &= \frac{\vec{R_{o_t}}}{|\vec{R_{o_t}}|} \\ \vec{F_f} &= -\min(|\vec{R_{o_t}}|, c_f|\vec{R_{o_n}}|) \; \vec{1_t} \end{aligned} $$</p>
	<p>Where \( \vec{R_{o}} \) is the resultant of the other forces. \( \vec{R_{o_t}} \) et \( \vec{R_{o_n}} \) are its tangential and normal components. \( \vec{1_n} \) is the unit vector normal to the surface. \( \vec{1_t} \) is the unit vector tangent to the surface in the same direction as \( \vec{R_{o_t}} \). \(c_f\) is the coefficient of friction. In short, the frictional force cancels out the tangential component of the other forces up to a certain point which depends on the normal component.</p>

	<p>After calculating the new vertex positions, we need to check for collisions with the sphere. The detection of collisions between a point and a sphere is extremely simple. If the distance between the point and the center of the sphere is smaller than the radius of the sphere, the point is in the sphere. In this case it must be repositioned on the surface. $$ \begin{aligned} \vec{CS} &= \vec{x_{s}} - \vec{x_c} \\ \vec{1_{cs}} &= \frac{\vec{CS}}{|\vec{CS}|} \\ \vec{x_{s_r}} &= \vec{x_c} + r \; \vec{1_{cs}} \end{aligned} $$</p>

	<p>Where \( x_s \) is the position of the vertex, \( x_c \) the position of the centre et \( x_{s_r} \) the position of the top after repositioning. Once the repositioning is done, the speed must be updated. $$ \vec{v} = \frac{\vec{x_{s_r}} - \vec{x_s}}{\Delta{}t} $$</p>

	<h2>Grading grid</h2>
	<ul>
		<li>The number of vertices of the fabric is easily editable in the Rust code. (4 points)</li>
		<li>The compute shader receives the position and radius of the sphere from the Rust code. (2 points).</li>
		<li>The parameters of the simulation (stiffness constants, vertex masses, ...) are easily editable in the Rust code. (2 points)</li>
		<li>The effect of gravity is simulated by the Compute Shader. (2 points)</li>
		<li>The fabric does not pass through the sphere. (2 points)</li>
		<li>The effect of the springs (Hooke's law) is simulated by the Compute Shader. (4 points)</li>
		<li>All three types of springs are present in the simulation. (2 points)</li>
		<li>The friction forces between the sphere and the fabric are simulated by the Compute Shader. (2 points)</li>
	</ul>
</body>
</html>
